<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="leaflet/leaflet.css" />
    <script src="leaflet/leaflet.js"></script>
    <link rel="stylesheet" href="leaflet/L.Control.MousePosition.css" />
    <script src="leaflet/L.Control.MousePosition.js"></script>
    <link rel="stylesheet" href="codemirror/addon/hint/show-hint.css">
    <script src="codemirror/lib/codemirror.js"></script>
    <link rel="stylesheet" href="codemirror/lib/codemirror.css">
    <script src="codemirror/mode/yaml/yaml.js"></script>
    <script src="codemirror/addon/hint/show-hint.js"></script>
    <link rel="stylesheet" href="codemirror/theme/base16-dark.css">
    <link rel="stylesheet" href="codemirror/theme/base16-light.css">
    <link rel="stylesheet" href="foldgutter.css" />
    <script src="leaflet.geometryutil.js"></script>
	  <script src="leaflet-arrowheads.js"></script>
    <script src="js-yaml.mjs"></script>
    <script src="leaflet-canvasicon.js" defer></script>
    <script src="debounce.js"></script>
    <script src="foldcode.js"></script>
    <script src="foldgutter.js"></script>
    <script src="indent-fold.js"></script>
    <!--
BSD 2-Clause License

Copyright (c) 2023, savage13@gmail.com

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

      -->
    <title>Not Celer (TotK)</title>
    <style>
      body {
          margin: 0;
          padding: 0;
      }
      #map {
          display: block;
          height: 100%;
          width: 100%;

      }
      #map0 {
          position: relative;
          width: 100%;
          height: 100%;
      }
      .CodeMirror {
          height: 100%;
          width: 100%;
      }
      #wrap {
          position: relative;
          width: 100%;
          display: flex;
          height: 100%;
          background: rgba(0,0,0,0.85);
      }
      #messages {
          position: absolute;
          display: none;
          left: 0;
          bottom: 0;
          width: 100%;
          font-family: sans-serif;
          background: rgba(0,0,0,0.7);
          color: white;
          min-height: 7em;
          padding: 1em;
          overflow: scroll;
      }
      #messages div pre {
          padding:0;
          margin: 0;
      }
      #messages button {
          cursor: pointer;
          position: relative;
          pointer-events: all;
      }
      .split {
          display: flex;
          flex-direction: row;
          height: 100vh;
          width: 100vw;
      }
      .gutter {
          background-color: #eee;
          background-repeat: no-repeat;
          background-position: 50%;
      }
      .gutter.gutter-horizontal {
          background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==');
          cursor: col-resize;
      }
      #route0 {
          position: relative;
          padding-top: 0.5em;
          padding-right: 0.0em;
          padding-bottom: 0.2em;
          background: black;
      }
      #route {
          width: 100%;
          height: 100%;
          overflow: scroll;
          background: black;
      }
      .segment {
          width: 100%;
      }
      .segment_data {
          display: table;
          table-layout: fixed;
          width: 100%;
      }
      .segment_title_text_pad {
          padding-left: 5.5em;
      }
      .segment_title_text {
      }
      .segment_title {
          font-family: sans-serif;
          background: black;
          color: yellow;
          font-size: 1.2em;
          display: flex;
          height: inherit;
          flex-flow: row nowrap;
      }
      .segment_title_layer {
          color: white;
          font-size: 0.7em;
          height: 100%;
          vertical-align: bottom;
          margin-left: auto;
          margin-right: 1em;
          margin-top: auto;
          margin-bottom: auto;
      }
      .segment_line {
          display: table-row;
          background: black;
          color: white;
          font-family: sans-serif;
          font-size: 0.9em;
          width: 100%;
      }
      .segment_line > div {
          padding: 0.2em;
          border-bottom: 1px solid rgba(255,255,255,0.2);
          border-left: 1px solid rgba(255,255,255,0.1);
      }
      .segment_line_number {
          border: 0px solid gray;
          display: table-cell;
          width:3em;
          vertical-align: top;
          cursor: pointer;
      }
      .segment_line_counter {
          border: 0px solid gray;
          display: table-cell;
          width:3em;
          vertical-align: top;
      }
      .segment_line_text {
          border: 0px solid gray;
          display: table-cell;
          min-width: 10em;
      }
      .segment_line_text_text {
          display: table-cell;
      }
      .segment_line_text_row {
          display: flex;
          flex-flow: row nowrap;
      }
      .segment_line_text_icon {
          width: 50px;
          min-width: 50px;
          height: 24px;
          text-align: center;
      }
      .segment_line_text_icon img {
          width: 100%;
          height: 100%;
      }
      .segment_line_text_column {
          display: flex;
          flex-flow: column nowrap;
          width: 100%;
      }
      .segment_line_text_comment {
          display: table-cell;
          vertical-align: top;
          font-size:0.9em;
          color: #cccccc
      }
      .even {
          color: black;
          background: #CCCCFB;
      }
      .odd {
          color: black;
          background: #EEC652;
      }
      .segment_line_notes {
          border: 0px solid gray;
          display: table-cell;
          max-width: 20%;
          vertical-align: top;
      }

      #missing_stub {
          cursor: pointer;
          font-family: sans-serif;
          font-size: 0.8em;
          color: white;
          padding: 0.5em;
          text-align: right;
          margin-right: 2em;
          opacity: 1;
      }
      #missing_stub:hover {
          color: lightblue;
      }
      #missing {
          font-family: sans-serif;
          position: absolute;
          bottom: 0;
          width: 98%;
          left: 0;
          display: flex;
          flex-flow: column nowrap;
          background: rgba(0,0,0,0.0);
          color: white;
          padding-left: 1em;
          padding-right: 1em;
          padding-top: 0.1em;
          padding-bottom: 0.1em;

      }
      #missing_data {
          overflow: scroll;
          height: 0px;
      }
      #missing_down {
          display:none;
      }
      #missing_up {
          display:inline;
      }
      .missing_show_hide {
          display: inline;
          font-size: 0.8em;
          cursor: pointer;
          vertical-align:middle;
          height: 100%;
      }
      .missing_show_hide:hover {
          color: lightblue;
      }
      .missing_summary {
          display: inline;
          width: 100%;
      }
      .missing_summary_box {
          display: inline-flex;
          flex-flow: row nowrap;
          width: 90%;
          align-items: center;
          justify-content: space-between;
      }
      summary {
          width: 100%;
      }
      summary:hover {
          background: rgba(30,30,30,0.8);
      }
      #theme {
          position: absolute;
          bottom: 0;
          right: 0;
          display: flex;
          flex-flow: row nowrap;
      }
      #search0 {
          position: absolute;
          z-index: 40000;
          bottom: 0;
          left: 0;
          background: rgba(0,0,0,0.4);
          padding: 0.5em;
          border: 0.5px solid rgba(255,255,255,0.3);
          border-radius: 0.3em;
          color: white;
      }
      #search0 input {
          background: inherit;
          color: inherit;
          width: 15em;
          border: 1px solid white;
          padding: 0.3em;
          border-radius: 0.3em;
      }
      #progress0 {
          position: absolute;
          z-index: 40000;
          top: 0;
          left: 50%;
          transform: translate(-50%,0) scale(0.75);
          background: rgba(0,0,0,1);
          color: lightblue;
          border: 0.5px solid rgba(255,255,255,0.3);
          border-radius: 0.3em;
          display: none;
      }
      #progress {
          font-family: sans-serif;
          padding: 0.3em;
      }
      #progress div {
          cursor: default;
      }
      #progress div img {
          width: 30px;
          height: 30px;
      }
      .itiny {
          font-style: italic;
          font-size: 0.7em;
      }
      .line_active {
          background: #f9f0c4;
          color: black;
      }
      .table {
          display: table;
      }
      .tr {
          display: table-row;
      }
      .td {
          display: table-cell;
          text-align: center;
          vertical-align: middle;
          padding-left: 0.2em;
          padding-right: 0.2em;
      }
      #settings {
          font-family: Helvetica, Arial, sans-serif;
          position: absolute;
          height: 200px;
          width: 400px;
          left: 0;
          right: 0;
          top: 50px;
          margin-left: auto;
          margin-right: auto;
          background: black;
          color: white;
          border: 1px solid darkgray;
          border-radius: 0.3em;
          padding: 0.2em;
          overflow: scroll;
          display: none;
          z-index: 3000;
      }
      .link {
          color: lightskyblue;
      }
      .line_active .link {
          color: #6699FF;
      }
      .segment_line_notes .link {
          color: black;
      }

      .leaflet-control-command-interior
{
    background-image: url(images/command.png);
    width: 46px;
    height: 46px;
    background-position: 50% 50%;
    background-repeat: no-repeat;
    display: flex;
    padding: 3px;
    padding-bottom:10px;

    line-height: 100%;
    justify-content: center;
    align-items: center;
    border-radius: 4px;
    box-shadow: 0 1px 7px rgba(0, 0, 0, 0.65);
    cursor: pointer;
    background-color: #FFFFFF;
    vertical-align: top;
    box-sizing: border-box;
}

      .leaflet-control-command-icon {
          font-size: 40pt;
          color: darkgray;
      }

.leaflet-control-command-content
{
    display: none;
    background: white;
    border-radius: 4px;
    box-shadow: 0 1px 7px rgba(0, 0, 0, 0.65);
    padding: 0.5em;
    position: absolute;
    top:0;
    right:0;
    width: 160px;
    overflow: scroll;
}
.leaflet-control-command-content button {
    font-size: 1em;
    min-width: 10em;
}
.leaflet-control-command-content input[type=text] {
    width: 10em;
}

.leaflet-control-command-interior:hover  .leaflet-control-command-content
{
    font-size: 1em;
    display: flex;
}
.leaflet-control-command-interior:hover  .leaflet-control-command-icon
{
    display: none;
}

#split_status {
    border-radius: 50px;
    width: 18px;
    height: 18px;
}

.status_error {
    border: 3px solid darkred;
    background: red;
}

.status_unknown {
    border: 3px solid darkgray;
    background: lightgray;
}
.status_connected {
    border: 3px solid darkblue;
    background: lightblue;
}
.status_stop {
    border: 3px solid darkred;
    background: pink;
}
.status_run {
    border: 3px solid darkgreen;
    background: lightgreen;
}
.status_pause {
    border: 3px solid yellow;
    background: lightyellow;
}

    </style>
  </head>
  <body>
    <div id="settings">
      <h3>Documentation / Settings</h3>
      <h4>Key Commands</h4>
      <ul>
        <li>Ctrl-g - Toggle Doc / Settings</li>
        <li>Ctrl-p - Toggle Progress</li>
        <li>Ctrl-o - Toggle Show only current segment</li>
        <li>Ctrl-i - Toggle Shift Title</li>
        <li>Ctrl-j - Toggle Search objmap window</li>
        <li>Ctrl-f - Fold all editor text</li>
        <li>Ctrl-u - Unfold all editor text</li>

      </ul>
      <h4>Builtin Items</h4>
      <p>
      Types that are defined can be found in the Missing Items list at the bottom of the route.
      You can add these items into your route.  If the item exists in your route, it will be removed
      from this list.
      <p>
      While writing your route you can TAB complete on the built in items. For example, type <tt>_Korok::</tt> then press TAB and
      those values will appear on the map along with a drop down list of the same items.
      Move your mouse over the marker you want to discover the item's name.

      <h4>Ancient Stone Tablets</h4>
      <p>Make sure that the Ancient Stone Tablets have a matching _Npc::Wortsworth otherwise they will not get
        counted towards you map%; this is the same as in the game.
      </p>
      
      <h4>Basic Document</h4>
      <pre>
---
_config:
_project:
  authors:
    - Author Name
  description: Route Description
  name: Route Name
  url: ""
  version: 1.0.0
_route:
  - Great Sky Island:
- _Warp::ROA:
       level: Sky
       line-color: rgb(255,128,128)
    - _Special::StartPos Sky
    - _Chest<Archaic Legwear>:
        coord: [361.13, 2334.30, -1631.99]
    - _Location::TempleofTime
      </pre>
    </div>
    <div id="app" class="split">
      <div id="wrap">
        <textarea id="editor"></textarea>
        <div id="messages"></div>
        <div id="theme">
          <button id="save">Save</button>
          <button id="splits" title="Save Hail/Mist Splits">Splits</button>
          <button id="splits_lss_button" title="Save Livesplit Splits">Splits (LSS)</button>
          <select id="themes">
            <option value="base16-dark">Dark</option>
            <option value="base16-light">Light</option>
          </select>
        </div>
      </div>
      <div id="route0">
        <div id="route"></div>
        <div id="missing">
          <div id="missing_stub">
            <div id="missing_up">&#9650;</div>
            <div id="missing_down">&#9660;</div>
            Missing Items</div>
          <div id="missing_data"></div>
        </div>
      </div>
      <div id="map0">
        <div id="map" game="totk"></div>
        <div id="search0">
          <input type="text" placeholder="Search objmap..." id="search">
        </div>
        <div id="progress0">
          <div id="progress" class="table">
            <div class="tr">
              <div class="td"><img src="tower.png"></div>
              <div class="td"><img src="shrine.png"></div>
              <div class="td"><img src="lightroot.png"></div>
              <div class="td"><img src="mapicon_korok.png"></div>
              <div class="td"><img src="frog.png"></div>
              <div class="td"><img src="sign.png"></div>
              <div class="td"><img src="cave.png"></div>
              <div class="td"><img src="well.svg"></div>
              <div class="td"><img src="chasm.png"></div>
              <div class="td"><img src="talus.png"></div>
              <div class="td"><img src="gleeok.png"></div>
              <div class="td"><img src="hinox.png"></div>
              <div class="td"><img src="frox.png"></div>
              <div class="td"><img src="molduga.png"></div>
              <div class="td"><img src="flux.png"></div>
              <div class="td"><img src="ponypoint.png"></div>
              <div class="td"><img src="poe_large.png"></div>
              <div class="td" id="progress_icon_mappct"><img src="World_Map.png"></div>
              <div class="td"><div id="split_status" class="status_unknown" title="Click to reconnect"></div></div>
            </div>
            <div class="tr">
              <div class="td" id="progress_Tower">0</div>
              <div class="td" id="progress_Shrine">0</div>
              <div class="td" id="progress_Lightroot">0</div>
              <div class="td" id="progress_Korok">0</div>
              <div class="td" id="progress_Bubbulfrog">0</div>
              <div class="td" id="progress_Addison">0</div>
              <div class="td" id="progress_Cave">0</div>
              <div class="td" id="progress_Well">0</div>
              <div class="td" id="progress_Chasm">0</div>
              <div class="td" id="progress_Enemy::Talus">0</div>
              <div class="td" id="progress_Enemy::Gleeok">0</div>
              <div class="td" id="progress_Enemy::Hinox">0</div>
              <div class="td" id="progress_Enemy::Frox">0</div>
              <div class="td" id="progress_Enemy::Molduga">0</div>
              <div class="td" id="progress_Enemy::FluxConstruct">0</div>
              <div class="td" id="progress_PonyPoint">0</div>
              <div class="td" id="progress_Poe">0</div>
              <div class="td" id="progress_mappct">0</div>
              <div class="td" id="split_segment"></div>
            </div>
          </div>
        </div>
          <!-- <zelda-map id="map" game="totk"></zelda-map>-->
      </div>
    </div>
    <script src="split.min.js"></script>
    <script>
      let sizes = localStorage.getItem('split-sizes')
      if(sizes)
          sizes = JSON.parse(sizes);
      else
          sizes = [20, 30, 50];
      Split([ '#wrap', '#route0','#map0'], {
          sizes: sizes,
          minSize: [0, 0, 300],
          onDragEnd: function (sizes) {
              localStorage.setItem('split-sizes', JSON.stringify(sizes))
          },
      })
      document.getElementById('missing_stub').addEventListener('click', (ev) => {
          const md = document.getElementById('missing_data')
          const h = md.offsetHeight;
          const up = document.getElementById('missing_up');
          const dn = document.getElementById('missing_down');
          const ms = document.getElementById('missing');
          if(h > 100) {
              md.style.height = '0px';
              style="display: inline;"
              up.style.display = 'inline';
              dn.style.display = 'none';
              ms.style.background = 'rgba(0,0,0,0)';
          } else {
              md.style.height = '200px';
              up.style.display = 'none';
              dn.style.display = 'inline';
              ms.style.background = 'rgba(0,0,0,0.8)';
          }

      });
    </script>
    <script>
      let exports = {};
    </script>
    <script src="./simple_text_parser.js"></script>
    <script>
      let parser = undefined

      function init_parser() {
          parser = new Parser()
          parser.addRule(/\.link\(\[([^\]]+)\]([^\)]+)\)/g, function(tag, g1, g2) {
              g1 = g1.replace("<", "&lt;").replace(">", "&gt;")
              return { type: "tag", text: `<a class="link" target="_blank" href="${g2}">${g1}</a>`, value: "hello" }
          })
          parser.addRule(/</g, function(tag) { return "&lt;" })
          parser.addRule(/>/g, function(tag) { return "&gt;" })
          //parser.addRule(/\.dir\(([^)]+)\)/g, function(tag, g1) {
          //    return { type: "tag", text: html`<span class="dir">${g1}</span>`, value: "dir" }
          //})
          parser.addRule(/\(\?=\)/g, function(tag) { return "" })
          parser.addRule(/\(==\)/g, function(tag) { return "" })
          parser.addRule(/\(!=\)/g, function(tag) { return "" })
          parser.addRule(/\(^=\)/g, function(tag) { return "" })
          parser.addRule(/\n/g, function(tag) {
              return { type: "tag", text: "<br/>", value: "newline"}
          })
          //parser.addRule(/.!!\(([^)]+)\)/g, function(tag, g1) {
          //    return { type: "tag", text: html`<span class="exclaim">${g1}</span>`, value: "dir" }
          //})
          //parser.addRule(/.boss\(([^)]+)\)/g, function(tag, g1) {
          //    return { type: "tag", text: html`<span class="boss">${g1}</span>`, value: "dir" }
          //})
          //parser.addRule(/.loc\(([^)]+)\)/g, function(tag, g1) {
          //    return { type: "tag", text: html`<span class="loc">${g1}</span>`, value: "dir" }
          //})
          //parser.addRule(/.enemy\(([^)]+)\)/g, function(tag, g1) {
          //    return { type: "tag", text: html`<span class="enemy">${g1}</span>`, value: "dir" }
          //})
          //parser.addRule(/.rune\(([^)]+)\)/g, function(tag, g1) {
          //    return { type: "tag", text: html`<span class="rune">${g1}</span>`, value: "dir" }
          //})
          //parser.addRule(/.gale\(([^)]*)\)/g, function(tag, g1) { return "Gale" })
          //parser.addRule(/.fury\(([^)]*)\)/g, function(tag, g1) { return "Fury" })
      }
      function formatter(txt) {
          if(!parser) {
              init_parser()
          }
          if(txt == "")
              return txt
          let tree = parser.toTree(txt)
          let out = ``
          for(const t of tree) {
              out = `${out}${t.text}`
          }
          return out
      }
      
    </script>
    <script defer>


      let SHOW_PROGRESS = false; // Ctrl-P
      let ONLY_SEGMENT = false;  // Ctrl-O
      let SHIFT_TITLE = false; // Ctrl-i
      let SETTINGS = false; // Ctrl-G
      let SEARCH = true; // Ctrl-J
      let REPORT_SPLITS = true;
      
      const game = "totk";

      const map_options = {
          TILE_SIZE: 256,
          MAP_SIZE: [24_000, 20_000],
          DEFAULT_ZOOM: 5,
          MIN_ZOOM: 1,
          MAX_ZOOM: 12,
      }
      const crs = L.Util.extend({}, L.CRS.Simple);
      // @ts-ignore
      crs.transformation = new L.Transformation(
          4 / map_options.TILE_SIZE,
          map_options.MAP_SIZE[0] / map_options.TILE_SIZE,
          4 / map_options.TILE_SIZE,
          map_options.MAP_SIZE[1] / map_options.TILE_SIZE);

      let map_el = {};

      const map_ele = document.getElementById('map');
          const map = new L.Map(map_ele, {
              attributionControl: false,
              zoom: map_options.DEFAULT_ZOOM,
              minZoom: map_options.MIN_ZOOM,
              maxZoom: map_options.MAX_ZOOM,
              maxBoundsViscosity: 1.0,
              crs,
              preferCanvas: true,
          })
          //L.control.attribution({ prefix: false }).addTo(map);
      map_el = {
          map: map,
          level: "Surface",
      }

      // from leaflet-rastercoords
      const zoomLevel = Math.ceil(
          Math.log(Math.max(map_options.MAP_SIZE[0], map_options.MAP_SIZE[1]) / map_options.TILE_SIZE) / Math.log(2)
      );
      var sW = map.unproject([0, map_options.MAP_SIZE[1]], zoomLevel);
      var nE = map.unproject([map_options.MAP_SIZE[0], 0], zoomLevel);
      map.setMaxBounds(L.latLngBounds(sW, nE));

      map.setView([0, 0], 3);
      const TOTK_MAP = "https://objmap-totk.zeldamods.org/game_files/map";
      const BOTW_MAP = "https://objmap.zeldamods.org";
      const AREAS = ["Sky", "Surface", "Depths"];

      const baseMapLayers = {};

      if (game == "totk") {
          for (const area of AREAS) {
              const zarea = (area == "Surface") ? "Ground" : area;
              baseMapLayers[area] = L.tileLayer(`${TOTK_MAP}/${zarea}/maptex/{z}/{x}/{y}.webp`, {
                  attribution: '<a href="https://objmap-totk.zeldamods.org/">Zeldamods Object Map</a>',
                  maxNativeZoom: 7,
              });
          }
          if (!(map_el.level in baseMapLayers))
              map_el.level = "Surface";
          baseMapLayers[map_el.level].addTo(map_el.map);
          L.control.layers(baseMapLayers).addTo(map_el.map);
      }

      L.Control.textbox = L.Control.extend({
          options: {
              position: 'topright',
          },
          onAdd: function(map) {
              var controlDiv = L.DomUtil.create('div', 'leaflet-control-command');
              const controlUI = L.DomUtil.create('div', 'leaflet-control-command-interior', controlDiv);
              const content = L.DomUtil.create('div', 'leaflet-control-command-content', controlUI)
              content.appendChild(this.options.html)
              controlUI.title = 'Map Commands';
              const icon = L.DomUtil.create('div', 'leaflet-control-command-icon', controlUI)
              icon.innerHTML = '&#9881;'
              return controlDiv;
          },
          onRemove: function(map) {
          }
      })

      function checkbox(label, id, checked, parent, onchange) {
          const progress_div = $div()
          parent.appendChild(progress_div)
          const progress = $input()
          progress.type = "checkbox"
          progress.id = id
          progress.checked = checked
          progress.addEventListener('change', onchange)
          progress_div.appendChild(progress)
          const progress_label = document.createElement('label')
          progress_label.textContent = label
          progress_label.htmlFor = id
          progress_div.appendChild(progress_label)
          return progress
      }
      function button(text, parent, title, onclick) {
          const div = $div()
          const b1 = $button()
          b1.textContent = text
          b1.title = title
          div.appendChild(b1)
          parent.appendChild(div)
          b1.addEventListener('click', onclick)
      }
      function input(placeholder, id, parent, title, onchange) {
          const div = $div()
          const inp = $input()
          inp.type = "text"
          inp.id = id
          inp.title = title
          inp.placeholder = placeholder
          inp.addEventListener('change', onchange)
          div.appendChild(inp)
          parent.appendChild(div)
          return div
      }
      function single(func) {
          return (ev) => {
              func();
              ev.stopPropagation()
              ev.preventDefault()
          }
      }

      L.control.textbox = function(opts) { return new L.Control.textbox(opts);}
      const settings = $div()
      settings.style.width = "100%"

      checkbox("Report Splits", "splits_id", REPORT_SPLITS, settings, single(toggle_report_splits))
      checkbox("Show progress", "progress_id", SHOW_PROGRESS, settings, single(toggle_show_progress))
      checkbox("Show current segment", "current_id", ONLY_SEGMENT, settings, single(toggle_only_segment))
      checkbox("Shift title", "title_id", SHIFT_TITLE, settings, single(toggle_shift_title))
      checkbox("Show search", "search_id", SEARCH, settings, single(toggle_search))
      const el = document.createElement('div')
      el.textContent = "Progress bar update"
      el.style.fontWeight = "bold"
      settings.appendChild(el)

      const div0 = document.createElement('div')
      const radio0 = document.createElement('input')
      radio0.type = "radio"
      radio0.value = "Update on line"
      radio0.id = "update_on_line"
      radio0.name = "progress_update"
      radio0.checked = false
      div0.appendChild(radio0)
      const label0 = document.createElement('label')
      label0.textContent = "Update on line"
      label0.htmlFor = "update_on_line"
      div0.appendChild(label0)
      settings.appendChild(div0)
      const div1 = document.createElement('div')
      const radio1 = document.createElement('input')
      radio1.type = "radio"
      radio1.value = "Update after line"
      radio1.id = "update_after_line"
      radio1.name = "progress_update"
      radio1.checked = true
      div1.appendChild(radio1)
      const label1 = document.createElement('label')
      label1.textContent = "Update after line"
      label1.htmlFor = "update_after_line"
      div1.appendChild(label1)
      settings.appendChild(div1)

      el.style.marginTop = "0.8em"
      div1.style.marginBottom = "0.8em"

      button("Fold editor text", settings, "Fold up all editor text", (ev) => { myCodeMirror.execCommand("foldAll")})
      button("Unfold editor text", settings, "Unfold all editor text", (ev) => { myCodeMirror.execCommand("unfoldAll")})
      button("Sync Split", settings, "Transfer speedrun timer split to not-celer", (ev) => {
          sync_with_hail()
      })
      button("Reset Splits", settings, "Reset speedrun timer", (ev) => {
          if(confirm("Are you sure you want to reset current run?")) {
              hail.reset()
          }
      })
      let link = $div()
      link.innerHTML = `<a href="doc.html" target="_blank">Documentation</a>`
      settings.appendChild(document.createElement("br"))
      settings.appendChild(link)
      /*
      input("Timer websocket", "address_id", settings,
            "Speedrun timer websocket address, Hail is localhost:3578 and Livesplit is localhost:16834/livesplit",
            (ev) => {
      })
            */
      
      L.control.textbox({ position: 'topright', html: settings }).addTo(map);
      class Livesplit {
          // https://github.com/livesplit/livesplit?tab=readme-ov-file#the-livesplit-server
          // ipconfig, use gateway address
          // access site from browser on windows, run livesplit on windows
          constructor(address) {
              this._status = document.getElementById("split_status")
              this._segment = document.getElementById("split_segment")
              this.run_data = {}
              this.cur_seg = undefined
              this.on_func = { }
              this.once_func = { }
              this.ws = undefined
              this.init(address)
          }
          init(address) {
              // Default Hail Speed run timer on localhost
              if(address == undefined || address.trim() == "") {
                  address = "localhost:16834/livesplit"
              }
              if(this.ws) {
                  console.log("close ws")
                  this.ws.close()
              }
              //console.log("init", address)
              this.ws = new WebSocket(`ws://${address}`)
              //console.log("init", this.ws)
              const self = this
              this.ws.onopen = () => {
                  console.log('ws opened on browser')
                  self.set_status("connected")
                  self.run()
                  self.status()
              }
              this.ws.onclose = () => {
                  console.log('ws closed on browser')
                  self.ws = undefined
                  self.set_status("error")
              }
              this.ws.onmessage = (message) => {
                  return
                  let event = undefined
                  const data = JSON.parse(message.data)
                  //console.log("MSG", data)
                  if(data.Data) {
                      const d = data.Data
                      //console.log("MSG (d)", d)
                      event = Object.keys(d)[0]
                      if(d.Run) {
                          self.run_data = d.Run
                      } else if(d.CurrentSeg !== undefined) {
                          self.set_segment( d.CurrentSeg )
                      } else if(d.IsRunning !== undefined) {
                          if(d.IsRunning)
                              self.set_status("run")
                          else
                              self.set_status("stop")
                      }
                  } else if(data.Change) {
                      const c = data.Change
                      //console.log("MSG (change)", c)
                      event = Object.keys(c)[0]
                      if(c.FinishSeg) {
                          self.set_status("run")
                      } else if(c == "Reset") {
                          self.set_status("stop")
                          self.set_segment(0);
                      } else if(c.ChangeSeg) {
                      } else if(c.StartSeg) {
                          if(c.StartSeg.segment === null){
                              self.set_status("stop")
                          } else {
                              self.set_status("run")
                              self.set_segment(c.StartSeg.segment);
                          }
                      }
                  }
                  if(event) {
                      if(self.once_func[event]) {
                          self.once_func[event](data)
                          delete self.once_func[event]
                      }
                      if(self.on_func[event]) {
                          self.on_func[key](data)
                      }
                  }
              }
              this.ws.onerror = (message) => {
                  console.log('error', message.data)
              }
          }
          check_splits() {
              this.once_func.Run = (data) => {
                  console.log("check splits", data)
                  const els = document.getElementsByClassName("segment_line");
                  let count = 0;
                  for(const el of els) {
                      if(el.dataset.split) {
                          count += 1
                      }
                  }
                  const timer_count = data.Data.Run.segment_names.length
                  if(count != timer_count) {
                      alert(`Timer splits (${timer_count}) do not match Route (${count})`)
                  }
              }
              this.run()
          }
          set_status(s) {
              //console.log("MSG set status", s)
              this._status.classList.remove(...this._status.classList)
              this._status.classList.add(`status_${s}`)
              const titles = {
                  run: "Running ...",
                  unknown: "Click to reconnect",
                  stop: "Stopped",
                  connected: "Connected",
                  pause: "Paused",
                  error: "Click to connect",
              }
              this._status.title = titles[s]
          }
          set_segment(n) {
              this.cur_seg = n
              this._segment.textContent = this.cur_seg
          }
          send(data) {
              if(this.ws && this.ws.readyState == 1)
                  this.ws.send(data + "\n")
          }
          status() {
              this.send({Data: "CurrentSeg"})
              this.send({Data: "IsRunning"})
          }
          run() { this.send({Data: "Run"}) }
          reset() { this.send("reset") }
          pause() { this.send("pause") }
          close() {
              if(this.ws && this.ws.readyState == 1)
                  this.ws.close()
          }
          reconnect(address) {
              this.close()
              this.init(address)
          }
          split() {
              if(REPORT_SPLITS) {
                  this.send("split")
              }
          }
          unsplit() {
              if(REPORT_SPLITS) {
                  this.send("unsplit")
              }
          }
          on_current_segment(func, once=true) {
              if(once)
                  this.once_func.CurrentSeg = func
              else
                  this.on_func.CurrentSeg = func
              console.log("SEND for Current Segment")
              this.send({Data: "CurrentSeg"})
          }
      }
      class Hail {
          constructor(address) {
              this._status = document.getElementById("split_status")
              this._segment = document.getElementById("split_segment")
              this.run_data = {}
              this.cur_seg = undefined
              this.on_func = { }
              this.once_func = { }
              this.ws = undefined
              this.init(address)
          }
          init(address) {
              // Default Hail Speed run timer on localhost
              if(address == undefined || address.trim() == "") {
                  address = "localhost:3578"
              }
              if(this.ws) {
                  console.log("close ws")
                  this.ws.close()
              }
              //console.log("init", address)
              this.ws = new WebSocket(`ws://${address}`)
              //console.log("init", this.ws)
              const self = this
              this.ws.onopen = () => {
                  console.log('ws opened on browser')
                  self.set_status("connected")
                  self.run()
                  self.status()
              }
              this.ws.onclose = () => {
                  console.log('ws closed on browser')
                  self.ws = undefined
                  self.set_status("error")
              }
              this.ws.onmessage = (message) => {
                  let event = undefined
                  const data = JSON.parse(message.data)
                  //console.log("MSG", data)
                  if(data.Data) {
                      const d = data.Data
                      //console.log("MSG (d)", d)
                      event = Object.keys(d)[0]
                      if(d.Run) {
                          self.run_data = d.Run
                      } else if(d.CurrentSeg !== undefined) {
                          self.set_segment( d.CurrentSeg )
                      } else if(d.IsRunning !== undefined) {
                          if(d.IsRunning)
                              self.set_status("run")
                          else
                              self.set_status("stop")
                      }
                  } else if(data.Change) {
                      const c = data.Change
                      //console.log("MSG (change)", c)
                      event = Object.keys(c)[0]
                      if(c.FinishSeg) {
                          self.set_status("run")
                      } else if(c == "Reset") {
                          self.set_status("stop")
                          self.set_segment(0);
                      } else if(c.ChangeSeg) {
                      } else if(c.StartSeg) {
                          if(c.StartSeg.segment === null){
                              self.set_status("stop")
                          } else {
                              self.set_status("run")
                              self.set_segment(c.StartSeg.segment);
                          }
                      }
                  }
                  if(event) {
                      if(self.once_func[event]) {
                          self.once_func[event](data)
                          delete self.once_func[event]
                      }
                      if(self.on_func[event]) {
                          self.on_func[key](data)
                      }
                  }
              }
              this.ws.onerror = (message) => {
                  console.log('error', message.data)
              }
          }
          check_splits() {
              this.once_func.Run = (data) => {
                  console.log("check splits", data)
                  const els = document.getElementsByClassName("segment_line");
                  let count = 0;
                  for(const el of els) {
                      if(el.dataset.split) {
                          count += 1
                      }
                  }
                  const timer_count = data.Data.Run.segment_names.length
                  if(count != timer_count) {
                      alert(`Timer splits (${timer_count}) do not match Route (${count})`)
                  }
              }
              this.run()
          }
          set_status(s) {
              //console.log("MSG set status", s)
              this._status.classList.remove(...this._status.classList)
              this._status.classList.add(`status_${s}`)
              const titles = {
                  run: "Running ...",
                  unknown: "Click to reconnect",
                  stop: "Stopped",
                  connected: "Connected",
                  pause: "Paused",
                  error: "Click to connect",
              }
              this._status.title = titles[s]
          }
          set_segment(n) {
              this.cur_seg = n
              this._segment.textContent = this.cur_seg
          }
          send(data) {
              if(this.ws && this.ws.readyState == 1)
                  this.ws.send(JSON.stringify(data))
          }
          status() {
              this.send({Data: "CurrentSeg"})
              this.send({Data: "IsRunning"})
          }
          run() { this.send({Data: "Run"}) }
          reset() { this.send({Change: "Reset"}) }
          pause() { this.send({Change: "Pause"}) }
          close() {
              if(this.ws && this.ws.readyState == 1)
                  this.ws.close()
          }
          reconnect(address) {
              this.close()
              this.init(address)
          }
          split() {
              if(REPORT_SPLITS) {
                  this.send({Change: "Split"})
              }
          }
          unsplit() {
              if(REPORT_SPLITS) {
                  this.send({Change: "Unsplit"})
              }
          }
          on_current_segment(func, once=true) {
              if(once)
                  this.once_func.CurrentSeg = func
              else
                  this.on_func.CurrentSeg = func
              console.log("SEND for Current Segment")
              this.send({Data: "CurrentSeg"})
          }
      }

      function sync_with_hail() {
          hail.on_current_segment( (data) => {
              const segment_id = data.Data.CurrentSeg
              //console.log("CURRENT SEGMENT", segment_id)
              const els = document.getElementsByClassName("segment_line");
              let count = 0
              let element_id = undefined
              for(const el of els) {
                  if(el.dataset.split) {
                      if(count == segment_id) {
                          element_id = el.id
                          break
                      }
                      count += 1
                  }
              }
              if(element_id) {
                  scroll_to_line(element_id)
              }
          })
      }

      const hail = new Hail()
      const _status = document.getElementById("split_status")
      _status.addEventListener("click", (ev) => {
          //const address = document.getElementById("address_id").value.trim()
          console.log("reconnect")
          hail.reconnect()
      })

      let data = undefined;

      const msg_el = document.getElementById('messages');

      function warn(msg) {
          msg_el.style.display = 'block';
          msg_el.innerHTML += `<div>${msg}</div>`
          console.error(msg);
      }

      function switch_segments(layer) {
          //console.log(map_el.map);
          Object.values(SEGMENTS).forEach(seg => {
              if(seg.layer == layer) {
                  //console.log(seg.group.getLayers());
                  seg.group.invoke('addTo', map_el.map)
              } else {
                  seg.group.invoke('remove')
              }
          });
      }

      const completions = [
      ]

      let COMPS = L.layerGroup();

      function meta_from_names(items) {
          return items.map(x => meta_get(x))
      }
      function synonyms(cm, option) {
          return new Promise(function(accept) {
              setTimeout(function() {
                  var cursor = cm.getCursor(), line = cm.getLine(cursor.line)
                  var start = cursor.ch, end = cursor.ch
                  while (start && /[A-Za-z0-9_:]/.test(line.charAt(start - 1))) --start
                  while (end < line.length && /[A-Za-z0-9_:]/.test(line.charAt(end))) ++end
                  const word = line.slice(start, end);
                  const k = word.lastIndexOf("::");
                  if(k == -1) {
                      console.log('accept null early')
                      return accept(null)
                  }
                  const prefix = word.slice(0,k+2);
                  //console.log('autocomplete', word, prefix);
                  const comp = completions;
                  for (var i = 0; i < comp.length; i++) {
                      if (comp[i].indexOf(prefix) != -1) {
                          const items = comp[i]
                                .filter(w => w.startsWith(word))
                                .filter(x => {
                                    let tmp = x.replace(/^_/, "")
                                    return !counter_has(tmp);
                                });
                          const data = {
                              list: items,
                              from: CodeMirror.Pos(cursor.line, start),
                              to: CodeMirror.Pos(cursor.line, end)
                          };
                          const meta_items = items
                                .map(x => x.replace(/^_/, ""))
                                .map(x => [x, meta_get(x)])
                                .filter(x => {
                                    return x[0] && x[1] && x[1].pos
                                })
                                .map(m => L.circleMarker(ll(m[1].pos), {
                                    color: '#ff2c00', radius: 7
                                }).bindTooltip(m[0]));
                          COMPS.invoke('remove');
                          COMPS.clearLayers();
                          meta_items.forEach(m => COMPS.addLayer(m));
                          CodeMirror.on(data, 'shown', () => {
                              COMPS.invoke('addTo', map_el.map);
                          });
                          CodeMirror.on(data, 'close', () => {
                              COMPS.invoke('remove');
                          });
                          return accept(data);
                      }
                  }
                  console.log('accept null')
                  return accept(null)
              }, 100)
          })
      }

      let theme = localStorage.getItem('theme') || 'base16-dark';
      localStorage.setItem('theme', theme);


      const myCodeMirror = CodeMirror.fromTextArea(
          document.getElementById('editor'), {
              lineNumbers: true,
              mode: 'yaml',
              foldGutter: true,
              gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
              extraKeys: {
                  "Tab": "autocomplete",
                  "Ctrl-F": cm => cm.execCommand("foldAll"),
                  "Ctrl-U": cm => cm.execCommand("unfoldAll"),
              },
              hintOptions: {
                  hint: synonyms,
                  shown: function()  {
                      console.log('show hints shown')
                  },
                  close: function()  {
                      console.log('show hints closed')
                  }
              },
              theme: theme,
          });

      document.getElementById('themes').addEventListener('change', (ev) => {
          const theme = ev.target.value;
          localStorage.setItem('theme', theme);
          myCodeMirror.setOption("theme", theme);
      });

      document.getElementById('save').addEventListener('click', (ev) => {
          let txt = myCodeMirror.getValue();
          const blob = new Blob([txt], { type: 'application/x-yaml' })
          const a = document.createElement('a')
          let description = "totk_celer_route";
          if(data._project && data._project.description) {
              description = data._project.description;
          } else if (data._project && data._project.name) {
              description = data._project.name;
          }
          description = description.replaceAll(" ", "_").replaceAll(",","")
          let when = new Date().toISOString().replace(/.\d+Z$/g, "") // Remove milliseconds
          a.href = URL.createObjectURL(blob);
          a.download = `${description}_${when}.yaml`;
          a.click();
      });
      document.getElementById('splits').addEventListener('click', (ev) => {
          let txt = SPLITS_RON;
          const blob = new Blob([txt], { type: 'text/plain' })
          const a = document.createElement('a')
          let description = "totk_celer_route";
          if(data._project && data._project.description) {
              description = data._project.description;
          } else if (data._project && data._project.name) {
              description = data._project.name;
          }
          description = description.replaceAll(" ", "_").replaceAll(",","")
          let when = new Date().toISOString().replace(/.\d+Z$/g, "") // Remove milliseconds
          a.href = URL.createObjectURL(blob);
          a.download = `${description}_splits_${when}.msf`;
          a.click();
      });

      function get_name(name) {
          return NAMES[name] || name
      }
      const search_debounce = debounce(search, 250)
      const OBJMAP_MARKERS = L.layerGroup();
      const TOTK_URL = "https://radar-totk.zeldamods.org/objs/MainAndMinusField/?q=";
      // =seeds&withMapNames=false&limit=2000
      async function search(value) {
          if(value.trim() == ""){
              OBJMAP_MARKERS.invoke('remove')
              OBJMAP_MARKERS.clearLayers();
          }
          const url = `${TOTK_URL}${value}&withMapNames=false&limit=2000`;
          let objs;
          try {
              const res = await fetch(url);
              objs = await res.json();
          } catch(e) {
              warn(e);
              return;
          }
          OBJMAP_MARKERS.invoke('remove')
          OBJMAP_MARKERS.clearLayers();
          for(const obj of objs) {
              const name = get_name(obj.name);
              const m = L.circleMarker(
                  [obj.pos[2],obj.pos[0]],
                  {radius: 6, color: '#ff2222'})
                    .bindTooltip(`<div>${name}</div><div class="itiny">Click marker to copy position</div>`)
                    .addTo(map_el.map)
                    .on('click', (ev) => {
                        const pos = `[${obj.pos[0]}, ${obj.pos[1]}, ${-obj.pos[2]}]`;
                        navigator.clipboard.writeText(pos);

                    });
              OBJMAP_MARKERS.addLayer(m);
          }
      }
      document.getElementById('search').addEventListener('input', (ev) => {
          search_debounce(ev.target.value)
      });

      function listener(event, state) {
          yaml_level += (event == "open") ? +1 : -1;
          if(event == "open")
              return
          if(yaml_level > 4 || yaml_level == 3)
              return
          if(!state.result)
              return

          // Add line number to objects
          // Store line numbers for string to be popped later
          const meta = { line_start: state.line_start, line_end: state.line_end, level: yaml_level }
          //console.log("state.result", state.result, yaml_level)
          if(typeof state.result == 'object')
              state.result._doc = meta

          else if (typeof state.result == 'string') {
              if(!src_map[state.result])
                  src_map[state.result] = []
              //console.log("Add to src_map", state.result, meta)
              src_map[state.result].push( meta )
          }
      }

      let yaml_level = 0
      let src_map = {}
      
      function set_route(txt) {
          localStorage.setItem("route.txt", txt)
      }
      async function get_route() {
          // api.github.com/gists/4a7a1736945936ec60eb0ef772ba350e
          //   files: first or with yaml ending
          //
          // raw.githubusercontent.com/savage13/sacio/master/License
          // github
          //   https://api.github.com/repos/
          //   https://api.github.com/repos/$username/$repo/contents/filepath
          //
          // gist
          //   https://api.github.com/gists/
          //   https://api.github.com/gists/$UID
          //     -> json.firstFile.content
          //
          // codeberg.org
          // https://codeberg.org/api/v1/repos/$username/$repo/raw/filepath
          // https://codeberg.org/api/v1/repos/31JSON/totk-100-glitchless/raw/totk-glitchless-hundo-notceler.txt
          /*
- Github Gist
  - `https://restite.org/notceler-totk/?gist=${gist_id}`
  - `https://restite.org/notceler-totk/?gist=4a7a1736945936ec60eb0ef772ba350e`
- Github Repo
  - `https://restite.org/notceler-totk/?github=${user}/${repo}/${branch}/${filepath}`
  - `https://restite.org/notceler-totk/?github=31JSON/totk-hundo-glitchless/main/totk-glitchless-hundo-notceler.txt`
- Codeberg
  - `https://restite.org/notceler-totk/?codeberg=${user}${repo}/raw/{$filepath}` 
  - `https://restite.org/notceler-totk/?codeberg=31JSON/totk-100-glitchless/raw/totk-glitchless-hundo-notceler.txt`
           */
          let url = new URL(window.location)
          const providers = {
              gist: "https://api.github.com/gists/",
              github: "https://raw.githubusercontent.com/",
              codeberg: "https://codeberg.org/api/v1/repos/",
          }
          for(const key of Object.keys(providers)) {
              let file = url.searchParams.get(key)
              if(file !== undefined && file !== null) {

                  const prefix = providers[key]
                  const res = await fetch(prefix + file)
                  let txt = ""
                  if(key == "gist") {
                      const out = await res.json()
                      txt = Object.values(out.files)[0].content
                  } else {
                      txt = await res.text()
                  }
                  return txt
              }
          }
          return localStorage.getItem("route.txt")
      }
      let NOW = true;
      const route_debounce = debounce(route_update, 1000);
      function route_update(txt) {
          yaml_level = 0
          src_map = {}
          let tmp_data;
          try {
              tmp_data = jsyaml.load(txt,{
                  listener: listener
              }); // Convert yaml to json
              xclear();   // Clears map and route
              data = tmp_data; // Save parsed data to global data variable, eeek!
              set_route(txt); // Saves route text to localStorage
              route(); // Draws map and route
          } catch(e) {
              msg_clear();
              console.log(e);
              warn('Parse Error')
              e.message.split("\n").forEach(msg => warn(`<pre>${msg}</pre>`));
          }
      }

      myCodeMirror.on('change', (instance, changeObj) => {
          const txt = instance.getValue();
          if(NOW) {
              route_update(txt);
              NOW = false;
              return
          }
          route_debounce(txt);
      });

      function save_metadata() {
          const blob = new Blob([JSON.stringify(meta, null, 2)], { type: 'application/json' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'celer_botw_metadata.json',
          a.click();
      }

      function ll(pt) {
          const n = pt.length;
          if(n == 3)
              return [pt[n-1], pt[0]]
          warn('Expected  3 points, got', n);
          return []
      }

      // Read raw coordinates (not from data files)
      //  - in format [E-W, U-D, N-S]
      //  - objmap report North as positive
      //  - in reality North is negative for the actual data
      //    - data files reported from radar are already as North negative
      //    - objmap flips the North-South values for display only
      function read_xyz(v) {
          if(v == undefined)
              return undefined
          return [v[0], v[1], -v[2]]
      }

      function get_map_icon(kind, n = undefined) {
          if(n <= 0 || kind == undefined)
              return undefined;
          n = (n !== undefined) ? n : kind.length;
          if(kind.length && kind[0].sub && kind[0].sub.startsWith("- Bomb Flower")) {
              if(Math.random() * 100 > 98)
                  return icons["Item::- Squirrel"]
              return icons["Item::- Bomb Flower"]
          }
          const key = kind.slice(0,n).map(v => v.name).join("::");
          let icon = icons[key];
          if(!icon) {
              if(n-2 >= 0) {
                  // Remove 2nd to last element to check for
                  //  Shrine::*::Start
                  //  Korok::*::Start
                  //  Korok::*::End
                  //  There is a better solution, but this works
                  let tmp = [...kind];
                  tmp.splice(n-2,1)
                  let key1 = tmp.map(v => v.name).join("::")
                  if(icons[key1])
                      return icons[key1]
              }
              return get_map_icon(kind, n - 1)
          }
          return icon
      }

      function marker(kind, pt, name, warp = false) {
          let icon = get_map_icon(kind);
          if(icon)
              return L.marker(ll(pt), { icon: icon }).bindTooltip(name);
          return L.circleMarker(ll(pt)).bindTooltip(name);
      }

      function parse_name_to_line(name) {
          const name_orig = name;
          if(name[0] != "_") {
              return {txt: name};
          }
          name = name.slice(1)
          let v = name.split('::');
          let warp = false;
          if(v[0] == "Warp") {
              warp = true;
              v = v.slice(1);
          }
          let m = meta;
          let sub = undefined;
          let ele = "";
          let kind = []
          for(const el of v) {
              const k = el.indexOf("<");
              ele = (k != -1) ? el.slice(0,k) : el;
              if(m[ele])
                  m = m[ele]
              else {
                  m = undefined;
                  break
              }
              let val = el;
              sub = undefined ;
              if(k != -1) {
                  sub = el.slice(k+1,-1);
                  if(sub.match(/^[-+0-9., ]+$/)) {
                      //pos = sub.split(",").map(x => parseFloat(x));
                      sub = "";
                  }
                  val = el.slice(0,k);
              }
              kind.push({ name: val, sub })
          }
          if(Array.isArray(m)) {
              // This is currently for Korok Trails only
              // Remove the last component, roll things back
              kind.pop()
              m = m.at(-1)
              ele = kind.at(-1).name
          }
          if(!m) {
              warn(`Error finding metadata for ${name_orig}`);
              m = {}
          }
          if(sub) {
              if(!sub.includes(",")) {
                  return {txt: sub, kind, warp, key: ele}
              }
              v = sub.split(",",2).map(x => x.trim());
              return {txt: v[0], comment: v[1], kind, warp, key: ele}
          }
          if(m.DisplayName)
              return {txt: m.DisplayName, kind, warp, key: ele }
          if(m.Id)
              return {txt: m.Id, kind, warp, key: ele }
          return {txt: name_orig, warp, key: ele, kind}
      }

      function parse_name(name, pos = undefined) {
          const name_orig = name;
          if(name[0] == '_') {
              //return {markers: [], to: []};
              name = name.slice(1);
          } else {
              return {to: [], markers: []}
          }
          //console.log(name, pos);
          let v = name.split('::');
          let warp = false;
          if(v[0] == "Warp") {
              warp = true;
              v = v.slice(1);
          }
          let n = (v.length > 1) ? v.length - 1 : v.length;
          let kind = [];
          let m = meta;
          let sub = undefined;
          for(const el of v) {
              const k = el.indexOf("<");
              const ele = (k != -1) ? el.slice(0,k) : el;
              if(m[ele])
                  m = m[ele]
              else {
                  m = undefined;
                  break
              }
              let val = el;
              if(k != -1) {
                  sub = el.slice(k+1,-1);
                  if(sub.match(/^[-+0-9., ]+$/)) {
                      pos = read_xyz( sub.split(",").map(x => parseFloat(x)) )
                  }
                  val = el.slice(0,k);
              }
              kind.push({name: val, sub })
          }
          if(!m) {
              warn(`Error finding metadata for ${name_orig}`);
              m = {}
          }
          if(Array.isArray(m)) {
              let to = m.map(v => v.pos)
              let markers = m.slice(0, m.length-1)
                  .map((v,i) => marker([{name: "Korok"},{name: `${i+1}`}],v.pos, v.DisplayName))
              let last = m.at(-1)
              markers.push( marker([{name: "Korok"}], last.pos, last.korok_id))
              return {markers, to }

          }
          if(!m.pos && !pos) {
              //warn(`Metadata for ${name_orig} lacks a pos field or location not set`)
              //console.log("Metadata for ", v, " lacks a pos field or location not set");
              return {markers: [], to: []};
          }
          if(m.pos && !pos)
              pos = m.pos;
          let xname = v.at(-1)
          if(xname == "Start") {
              xname = v.slice(-2).join(" ")
          }
          if(xname == "End") {
              xname = v.at(-2)
          }
          const to = (warp) ? [[], pos]: [pos];
          const markers = [ marker(kind, pos, xname, warp)]

          return {to, markers, icon: kind, keys: xname }
      }

      function parse_movements(moves) {
          const marker_states = ['all', 'start', 'end']
          let marker = 'end';
          const to = [];
          const away = [];
          for(const v of moves) {
              if(v.marker) {
                  let value = v.marker.toLowerCase();
                  if(marker_states.includes(value)) {
                      marker = value
                  } else
                      warn(`Unknown movement marker value: ${v.marker} [${marker_states}]`)
                  continue
              }
              if(v.to === undefined)
                  continue
              let pos = read_xyz(v.to);
              if(v.warp === true && v.away == true) {
              } else if(v.away == true && !v.warp) {
                  if(to.length)
                      away.push([to.at(-1), pos])
                  else
                      away.push([pos]);
              } else if(v.warp == true && !v.away) {
                  to.push([])
                  to.push(pos);
              } else {
                  to.push(pos)
              }
          }
          return {to, marker, away }
      }

      function parse_object_header(obj, keys) {
          let to = [];
          let markers = [];
          let pos = undefined;
          let icon = undefined;
          let has_movement = false;
          if(!obj[keys])
              return {to, markers}
          if(obj[keys]['hide-icon-on-map'] || keys.startsWith('_Tod::')) {
              return {to, markers}
          }
          if(obj[keys]['movements'])
              has_movement = true;

          // Find possible position
          if(obj[keys]['coord'])
              pos = read_xyz(obj[keys]['coord'])
          else if(obj[keys].movements && obj[keys].movements.some(m => m.to)) {
              const p = obj[keys].movements.find(m => m.to);
              pos = read_xyz(p.to)
          }
          // Find Icon
          if(obj[keys].icon && pos)
              return { to: [pos], markers: [marker(obj[keys].icon,pos,keys, false)],
                       icon: obj[keys].icon, keys
                     }
          //console.log("Parse name", keys, pos);
          const ret = parse_name(keys, pos);
          //if(ret.to.length == 0)
          //    warn(`No coord: or movement::to: found for ${JSON.stringify(obj)}`)
          if(has_movement) {
              ret.markers = [];
              ret.to = [];
          }
          return ret;
      }
      function capitalize(str) {
          if(!str)
              return undefined;
          return str.charAt(0).toUpperCase() + str.slice(1);
      }
      function parse_object(obj) {
          let keys = Object.keys(obj).filter(v => v != '_doc');
          if(keys.length != 1) {
              console.log("Keys > 1");
              return [];
          }
          const to = []
          const away = [];
          const markers = [];
          let marker_icon = undefined;
          let marker_keys = undefined;
          let hide_icon_on_map = false;
          keys = keys[0]
          if(keys[0] == "_") {
              const ret = parse_object_header(obj, keys);
              to.push(...ret.to);
              markers.push(...ret.markers);
              marker_icon = ret.icon;
              marker_keys = ret.keys;
          }
          const vals = Object.values(obj)[0];
          if(vals === undefined || vals === null)
              return {to, markers, away}
          let line_color = undefined;
          let level_set = undefined;
          for(const [key, val] of Object.entries(vals)) {
              if(key == "movements") {
                  const ret = parse_movements(val);
                  to.push(... ret.to);
                  const n = ret.to.length;
                  if(ret.marker == 'start' && n) {
                      markers.push( marker(marker_icon, ret.to[0], marker_keys))
                  } else if(ret.marker == 'end' && n) {
                      markers.push( marker(marker_icon, ret.to[n-1], marker_keys))
                  } else if(ret.marker == 'all' && n) {
                      markers.push( ... ret.to.map(pt => marker(marker_icon, pt, marker_keys)))
                  }
                  if(ret.away.length) {
                      away.push(...ret.away)
                      if(marker_icon) {
                          markers.push( ... ret.away.map(pt => marker(marker_icon, pt.at(-1), marker_keys)))
                      }
                  }
              } else if (key == "comment") {
              } else if (key == "line-color") {
                  line_color = val;
              } else if (key == "level") {
                  const tmp = capitalize(val);
                  if(AREAS.includes(tmp))
                      level_set = val;
                  else if(tmp == "Ground")
                      level_set = "Surface"
                  else
                      warn(`Unknown level: ${val} [${AREAS}]`)
              } else if (key == "hide-icon-on-map") {
                  hide_icon_on_map = val;
              } else if (key == "notes") {
              } else if (key == "icon") {
              } else if (key == "gale") {
              } else if (key == "fury") {
              } else if (key == "split-type") {
              } else if (key == "time-override") {
              } else if (key == "coord") {
                  if(val.length != 3) {
                      warn(`Expected [EW, UD, NS], got a length of ${val.length}`)
                  } else {
                      val[2] = -val[2];
                  }
                  to.push( val )
              } else {
                  console.log("unexpected object key", key, vals, obj);
              }
          }
          if(hide_icon_on_map) {
              to.length = 0
              markers.length = 0
          }
          //console.log(to);
          return {to, markers, line_color, level: level_set, away}
      }

      let SEGMENTS = {};

      function msg_clear() {
          msg_el.innerHTML = "";
          const but = document.createElement('button');
          but.innerHTML = 'Dismiss';
          but.id = "dismiss";
          msg_el.appendChild(but);
          msg_el.style.display = 'none';
          but.addEventListener('click', msg_clear)
          msg_el.addEventListener('click', (ev) => {
              if(ev.target.id == "dismiss") {
                  msg_clear();
              }
          });
      }

      let _counters = {
          Korok: {},
          Shrine: {},
          Lightroot: {},
          Addison: {},
          Tower: {},
          Bubbulfrog: {},
          Cave: {},
          Chest: {},
          GoddessStatue: {},
          Well: {},
          Dispenser: {},
          Fairy: {},
          Tear: {},
          Tablet: {},
          Special: {},
          Shop: {},
          Temple: {},
          Location: {},
          Place:{},
          Chasm: {},
          OldMap: {},
          SagesWill: {},
          YigaSchema: {},
          SchemaStone: {},
          TechLab: {},
          SideAdv: {},
          MainQuest: {},
          SideQuest: {},
          KeyItem: {},
          PonyPoint: {},
          Poe: {},
          'Enemy::Talus': {},
          'Enemy::Gleeok': {},
          'Enemy::Hinox': {},
          'Enemy::Frox': {},
          'Enemy::Molduga': {},
          'Enemy::FluxConstruct': {},
          'mappct': {},
      };
      function counter_reset() {
          Object.keys(_counters).forEach(k => {_counters[k] = {};});
      }
      function sum(vals) {
          return vals.reduce((partialSum, a) => partialSum + a, 0);
      }

      function counter_total() {
          const out = {};
          for(const [key, value] of Object.entries(_counters)) {
              out[key] = sum(Object.values(value))
          }
          return out;
      }

      function counter_has(key) {
          const v = key.split("::");
          const name = v.pop();
          key = v.join("::");
          return key in _counters && name in _counters[key];
      }

      function counter_mappct_flag(flag) {
          const dups = ["Korok", "Shrine"]
          if(!flag || !(flag in mappct_flag))
              return
          for(const item of mappct_flag[flag]) {
              _counters.mappct[item.hash_id[0]] = 1;
              if(meta_hash[item.hash_id[0]].__key) {
                  let key = meta_hash[item.hash_id[0]].__key;
                  const name = key.at(-1)
                  key = key.slice(0,-1).toString()
                  if(key in _counters) {
                      if( dups.includes(key) &&
                          (name in _counters[key]) &&
                          _counters[key][name] > 0) {
                          warn(`Duplicate of ${key} ${name}`)
                      }
                      _counters[key][name] = 1;
                  } else {
                      console.log(`Error finding ${key} in counters`)
                  }
              }
          }
      }

      let POUCH = {};
      let POUCH_LOGIC = {};
      function pouch_logic(key, name) {
          const full = [key,name].join("::")
          const logic = POUCH_LOGIC[full];
          if(logic === undefined)
              return undefined;
          if(logic.action == "add")
              _counters[key][name] += logic.value
          if(logic.action == "pouch_add") {
              POUCH[[key,name].join("::")] = { key, name, full }
              _counters[key][name] = 1;
          }
          if(logic.action == "pouch_get") {
              if(key in _counters)
                  _counters[key][name] = 1;
              for(const key_name of logic.items) {
                  let item = POUCH[key_name];
                  if(!item)
                      continue
                  _counters[item.key][item.name] = 1
                  if(logic.mappct !== false) {
                      counter_inc_mappct(item.key, item.name)
                  }
                  delete POUCH[key_name]
              }
          }
          if(logic.mappct !== false)
              counter_inc_mappct(key, name)
          if(key in _counters)
              return { count: sum( Object.values(_counters[key]) ) }
          return { }
      }

      function counter_inc_mappct(key, name) {
          const tmp = [key,name].join("::")
          const m = meta_get(tmp);
          if(m === undefined || m.mappct === undefined)
              return false

          counter_mappct_flag(m.mappct.flag)
          m.mappct.flag_alt.forEach(alt => counter_mappct_flag(alt))
          return true
      }

      function counter_inc(key, name, warp) {
          const ignore_dups = {'GoddessStatue': true, 'PonyPoint': true, 'Poe': true }
          const multiple = { PonyPoint: true, Poe: { Large: 5, Grand: 20 } }

          if(warp)
              return undefined
          if(!key)
              return undefined;
          if(key.length == 0)
              return undefined
          if(key[key.length-1].name == 'Start')
              return undefined;
          if(key[key.length-1].name == 'End') {
              key.pop()
              if(name == 'End') {
                  name = key[key.length-1].name
              }
          }
          let orig_key = key
          key = key.slice(0,-1).map(k => k.name).join('::')

          let ret = pouch_logic(key, name);
          if(ret !== undefined)
              return ret;

          if(key in _counters) {
              let has_mappct = counter_inc_mappct(key, name);
              if(name in _counters[key] && !has_mappct && !ignore_dups[key])
                  warn(`Duplicate of ${key} ${name}`)
              if(multiple[key]) {
                  if(!(name in _counters[key])) {
                      _counters[key][name] = 0
                  }
                  let sub = undefined
                  if(orig_key.at(-1).sub) {
                      sub = parseInt(orig_key.at(-1).sub.replace("x",""))
                  }
                  if(sub)
                      _counters[key][name] += sub
                  else if(multiple[key][name])
                      _counters[key][name] += multiple[key][name]
                  else
                      _counters[key][name] += 1
              } else {
                  _counters[key][name] = 1
              }
              if(key == 'Korok') {
                  const korok = meta[key][name];
                  if(korok && korok.korok_type == "Korok Friends")
                      _counters[key][name] += 1;
              }
              return { count: sum( Object.values(_counters[key]) ) };
          }
          return undefined;
      }

      function xclear() {
          msg_clear();
          route_el.innerHTML = "";
          Object.values(SEGMENTS).forEach(v => v.group.invoke('remove'));
          Object.values(SEGMENTS).forEach(g => g.group.clearLayers())
          nsegments = 1;
          SEGMENTS = {};
          PROGRESS = {};
          nlines = 1;
          notes_class = "even";
          counter_reset();
      }

      function mean(vals) {
          if(vals.length == 0)
              return undefined;
          let sum = 0;
          for(const v of vals) {
              if(v === undefined)
                  continue
              sum += v;
          }
          sum = sum / vals.length;
          return sum;
      }

      const arrowhead_opts = {
          size: '4px',
          yawn: 60,
          frequency: '66px',
          fill: false,
      }

      let SPLITS = {}
      let SPLITS_RON = ""
      function reset_splits() {
          SPLITS = {
              game_title:` "Legend of Zelda: Tears of the Kingdom"`,
              category: `"${data._project.name}"`,
              offset: "Time(0)",
              pb: "None",
              splits: [],
              pb_times: [],
              gold_times: [],
              sum_times: []
          }
      }

      let SPLIT_TYPES = ["Shrine", "Tower"]
      function is_split_type(part) {
          for(const t of SPLIT_TYPES) {
              if(part.startsWith("_" + t))
                  return true
          }
          return false
      }

      function add_split_maybe(part, obj, force = false) {
          const is_user_split = (obj && obj['split-type'] !== undefined)
          if(is_user_split || force || (is_split_type(part) && part.split("::").length == 2)) {
              let v = part.split("::")
              v[0] = v[0].replace("_","")
              v = v.map(vi => vi.replaceAll("'", "\\'"))
              if(is_user_split && obj['split-type'] == "Start")
                  return true
              add_split(v.join(" "), part)
              return true
          }
          return false
      }

      function add_split(name, _key) {
          SPLITS.splits.push(`"${name}"`)
          SPLITS.pb_times.push("None"),
          SPLITS.gold_times.push("None"),
          SPLITS.sum_times.push("(1, None)")
      }

      function route() {
          reset_splits()

          if(data._project && data._project.split) {
              SPLIT_TYPES = data._project.split
          }
          
          //add_split("Start",'Start') // Not sure if we need this here
          let line_color = undefined;
          let last_point = undefined;
          let last_line = undefined
          for(const segment of data._route) {
              let level_set = undefined;
              for(const [name, parts] of Object.entries(segment)) {
                  if(name == "_doc")
                      continue
                  const pts = [];
                  const markers = [];
                  const lines = [];
                  const elevation = [];
                  const away = []
                  let FLY_TO = [];
                  let SPLIT_LINES = []
                  let markers_by_line = {};
                  let i = 0;

                  let docs = []
                  for(const part of parts) {
                      const kind = typeof part;
                      let _doc = {}
                      if(kind == "string") {
                          if(part in src_map) {
                              _doc = src_map[part].shift()
                          } else {
                              console.log("unknown line in src_map", part)
                          }
                          SPLIT_LINES.push( add_split_maybe(part, {}) )
                          const ret = parse_name(part);
                          elevation.push(... ret.to.map(x => x[1]))
                          pts.push(... ret.to);
                          markers_by_line[i] = [...ret.markers];
                          markers.push(... ret.markers)
                          line_color = (ret.line_color) ? ret.line_color : line_color;
                          level_set = (ret.level) ? ret.level : level_set;
                          FLY_TO.push( ret.to.find(x => x.length) )
                      } else if(kind == "object") {
                          _doc = part._doc
                          const _part_name = Object.keys(part).at(0)
                          SPLIT_LINES.push( add_split_maybe(_part_name, part[_part_name]) )
                          const ret = parse_object(part);
                          elevation.push(... ret.to.map(x => x[1]))
                          if(ret.away.length) {
                              for(const aw of ret.away) {
                                  if(aw.length == 2)
                                      away.push(aw)
                                  else if(aw.length == 1)
                                      away.push([pts.at(-1), aw[0]])
                                  else
                                      console.log("Expected length of 1 or 2 for 'away'")
                              }
                          }
                          pts.push(... ret.to);
                          markers_by_line[i] = [...ret.markers];
                          markers.push(... ret.markers)
                          line_color = (ret.line_color) ? ret.line_color : line_color;
                          level_set = (ret.level) ? ret.level : level_set;
                          if(ret.to.length)
                              FLY_TO.push( ret.to.find(x => x.length ) )
                          else
                              FLY_TO.push( pts.at(-1) )
                      } else {
                          console.log("unexpected kind", kind);
                          FLY_TO.push( [0,0,0])
                      }
                      docs.push(_doc)
                      i += 1;
                  }
                  // Determine Layer from mean of Elevation (y-coord or pos[1])
                  const mean_ele = mean(elevation);
                  let layer = "Surface";
                  if(mean_ele === undefined) {
                  } else if(mean_ele < 0) {
                      layer = "Depths";
                  } else if(mean_ele > 1000) {
                      layer = "Sky";
                  }
                  if(level_set !== undefined) {
                      layer = level_set;
                  }
                  const seg = route_new_segment(name, layer);

                  for(let i = 0; i < parts.length; i++) {
                      const part = parts[i];
                      markers_by_line[i].forEach(m => m.line_number = nlines);
                      const div = route_new_line(part, FLY_TO[i], layer, name, SPLIT_LINES[i], docs[i]);
                      if(div)
                          seg.appendChild(div)
                  }
                  last_line = parts.at(-1)

                  let pl = undefined;
                  if(last_point && last_point.length > 0 && pts.length > 0 && pts[0].length > 0) {
                      let m = [
                          [last_point[2], last_point[0]],
                          [pts[0][2], pts[0][0]]
                      ];
                      pl = L.polyline(m, {color: line_color }).bindTooltip('segment connection', {sticky: true})
                          .arrowheads(arrowhead_opts);
                  }

                  // Get Last actual point
                  let n = pts.length;
                  last_point = pts[n-1];

                  let multi = [];
                  let xll = [];
                  for(const pt of pts) {
                      if(pt.length == 3)
                          xll.push([pt[2], pt[0]])
                      else if(pt.length == 0) {
                          multi.push(xll);
                          xll = [];
                      }
                  }
                  if(xll.length > 0) {
                      multi.push(xll);
                  }
                  multi = multi.filter(m => m.length);
                  if(line_color === undefined) {
                      line_color = '#3388ff';
                  }
                  const tmp = multi.map(m =>
                      L.polyline(m, { color: line_color } ).bindTooltip(name, { sticky: true })
                          .arrowheads(arrowhead_opts)
                  )
                  if(pl)
                      tmp.push(pl);
                  if(away.length) {
                      const away_pl = away
                            .map(pts => pts.map(pt => ll(pt)))
                            .map(pts => L.polyline(pts, { color: 'white' })
                                 .bindTooltip(name, { sticky: true })
                                 .arrowheads(arrowhead_opts)
                                )
                      tmp.push(...away_pl);
                  }
                  SEGMENTS[name] = {
                      layer,
                      group: L.layerGroup(tmp),
                  }
                  markers.forEach(marker => { SEGMENTS[name].group.addLayer(marker); });
                  markers.forEach(marker => marker.on('click', (ev) => {
                      if(ev.target.line_number !== undefined)
                          scroll_to_line(`line_${ev.target.line_number}`);
                  }))
                  if(SEGMENTS[name].layer == map_el.level) {
                      SEGMENTS[name].group.invoke('addTo', map_el.map);
                  }
                  //MARKERS.push(...markers);
              }
          }
          // Add Last Split
          {
              if(typeof last_line == "string") {
                  //add_split_maybe(last_line, {}, true)
              } else if(typeof last_line == "object") {
                  const _part_name = Object.keys(last_line).at(0)
                  //add_split_maybe(_part_name, last_line[_part_name], true)

              }
          }
          {
              const last = document.getElementById(`line_${nlines-1}`)
              last.dataset.split = true
          }
          // Convert splits to ron
          {
              let nsplits = SPLITS.splits.length
              console.log("Splits", nsplits)
              let ron = ["version 2","("]
              for(const [key,val] of Object.entries(SPLITS)) {
                  if(typeof val == 'string') {
                      ron.push(`   ${key}: ${val},`)
                  } else {
                      ron.push(`   ${key}: [`)
                      for(const v of val) {
                          ron.push(`        ${v},`)
                      }
                      ron.push(`   ],`)
                  }
              }
              ron.push(")")
              SPLITS_RON = ron.join("\n")

          }
          {
              const missing = document.getElementById('missing_data');
              missing.innerHTML = "";
              const free_items = ["SageOfGerudo_IsCompleted_Exp",
                                  "SageOfGerudo_IsAfter_DungeonBossDead_Exp"]
              for(const key of Object.keys(_counters).sort()) {
                  const det = document.createElement('details');
                  const sum = document.createElement('summary');
                  const vals = key.split('::');
                  let items = meta;
                  for(const v of vals) {
                      items = items[v];
                  }
                  if(!items)
                      continue
                  const ul = document.createElement('ul');
                  ul.style.marginTop = 0;
                  ul.style.marginBottom = 0;
                  ul.style.fontSize = '0.90em';
                  det.appendChild(ul);
                  for(const item of Object.keys(items).sort()) {
                      if(item in _counters[key])
                          continue
                      let free = ""
                      if(items[item].flag) {
                          if(free_items.includes(items[item].flag))
                              free = " (via Lightning Temple)"
                          if(items[item].flag.startsWith("IsOpenCannon."))
                              free = " (via Tower)"
                      }
                      const name = document.createElement('li')
                      name.textContent = item + free;
                      ul.appendChild(name);
                  }
                  const xsum = $div();
                  sum.appendChild(xsum);
                  xsum.classList.add('missing_summary_box');
                  const txt = $div();
                  txt.textContent = key;
                  txt.classList.add('missing_summary');
                  xsum.appendChild(txt);

                  const show = $div();
                  const id = key.replace("::", "_");
                  show.textContent = "Show"
                  show.classList.add('missing_show_hide');
                  show.addEventListener('click', (ev) => {
                      ev.stopPropagation();
                      ev.preventDefault();
                      if(ev.target.textContent == "Show") {
                          show_type(key);
                          ev.target.textContent = "Hide";
                      } else {
                          hide_type(key);
                          ev.target.textContent = "Show";
                      }
                  });
                  xsum.appendChild(show);

                  det.appendChild(sum);
                  missing.appendChild(det);
              }
          }
      }

      function meta_get(key) {
          const vals = key.split("::");
          let items = meta;
          for(const v of vals) {
              items = items[v];
          }
          return items;
      }
      const ALL_MARKERS = {};
      function show_type(key_base) {
          const items = meta_get(key_base);
          if(!items)
              return;
          const group = Object.keys(items).filter(key => {
              return ! counter_has(`${key_base}::${key}`)
          }).map(key => {
              const v = items[key];
              let tooltip = (v.DisplayName != key) ? `${v.DisplayName} ${key}` : key;
              return L.circleMarker(ll(v.pos), { radius: 6, color: '#ff2222'}).bindTooltip(tooltip)
          })
          ALL_MARKERS[key_base] = L.layerGroup(group);
          ALL_MARKERS[key_base].invoke('addTo', map_el.map);
      }
      function hide_type(key) {
          const group = ALL_MARKERS[key];
          if(!group)
              return
          group.invoke('remove')
      }



      async function load_json(filename) {
          const res = await fetch(filename);
          return await res.json();
      }

      let meta = {};
      let icons = {};
      let mappct_data = {} // data from map_pct2.json
      let meta_hash = {}; // hash index into meta data
      let mappct = {}; // key: hash_id; value: map_pct data
      let mappct_flag = {} // key: flag; value: [ map_pct with that flag ]

      function get_hash_ids(obj, key0) {
          if(typeof obj != 'object' || obj === null) {
              return
          }
          if(obj.hash_id) {
              if(obj.hash_id in meta_hash) {
                  //console.log("Duplicate hash in meta_hash", obj.hash_id, obj.DisplayName)
              }
              meta_hash[obj.hash_id] = obj
              meta_hash[obj.hash_id].__key = [...key0]
              return
          }
          for(const [key1, value] of Object.entries(obj)) {
              key = [ ... key0]
              key.push(key1)
              get_hash_ids(value, key)
          }
      }

      const loadIcon = (name, opts) => new Promise( resolve => {
          if(opts.canvas) {
              opts.img = new Image();
              opts.img.src = opts.iconUrl;
              opts.drawIcon = function(canvas, type) {
                  if(type == "icon") {
                      const ctx = canvas.getContext('2d')
                      ctx.drawImage(opts.img, 0, 0, opts.iconSize[0],opts.iconSize[1])
                  }
              }
              opts.img.onload = function() {
                  resolve( L.canvasIcon( opts ))
              }
          } else {
              resolve(L.icon(opts))
          }
      });

      function isObject(x) {
          return(typeof x === 'object' && !Array.isArray(x) && x !== null);
      }

      let NAMES = {};

      async function main() {
          let txt = await get_route();
          if(!txt) {
              warn("Populating with basic initial route")
              const res = await fetch('main.celer');
              txt = await res.text();
          }
          POUCH_LOGIC = await load_json('pouch_logic.json')
          meta = await load_json('celer_totk_metadata.json')
          if(meta._icons) {
              for(const [name, opts] of Object.entries(meta._icons)) {
                  if(opts.iconUrl)
                      icons[name] = await loadIcon(name, opts)
                  for(const [name2, opts2] of Object.entries(meta._icons[name])) {
                      if(isObject(opts2) && name2 != "img") {
                          icons[`${name}::${name2}`] = await loadIcon(name2, opts2);
                      }
                  }
              }
          }

          get_hash_ids(meta, [])

          mappct = {}
          mappct_data = await load_json('map_pct2.json')
          flag_alts = await load_json('flag_alt.json')
          let total = 0;
          for(const [key, values] of Object.entries(mappct_data)) {
              total += values.length;
              for(const value of values) {
                  if(meta_hash[value.hash_id[0]]) {
                      if(value.hash_id[0] in mappct) {
                          console.log("hash already in mappct ", value.hash_id[0], value)
                      }
                      mappct[value.hash_id[0]] = meta_hash[value.hash_id[0]]
                      mappct[value.hash_id[0]].mappct = value
                      if(value.flag == undefined)
                          console.log('flag not defined for', value)
                      if(!(value.flag in mappct_flag))
                          mappct_flag[value.flag] = []
                      mappct_flag[value.flag].push(value)
                      value.flag_alt = [];
                      if(flag_alts[value.flag])
                          value.flag_alt.push( ... flag_alts[value.flag] )
                  } else {
                      console.log("cound not find matching location for ",
                                  value, value.hash_id[0])
                  }
              }
          }
          //console.log(total, Object.keys(mappct).length)

          // Set alt flags for everything based on name
          for(const [cat, values] of Object.entries(meta)) {
              if(cat == '_icons')
                  continue
              for(const [key,value] of Object.entries(values)) {
                  if(key in flag_alts) {
                      //console.log(`setting alt flag for ${cat} :: ${key}`)
                      if(!value.mappct)
                          value.mappct = {}
                      value.mappct.flag_alt = [... flag_alts[key]]
                  }
              }
          }

          for(const word of Object.keys(meta)) {
              if(word == "Enemy") {
                  for(const sub of Object.keys(meta[word])) {
                      completions.push([`_Enemy::${sub}::`, ... Object.keys(meta[word][sub]).sort().map(s => `_Enemy::${sub}::${s}`)]);
                  }
              }
              const dc = (word == "Enemy") ? "::" : "";
              completions.push([`_${word}::`, ... Object.keys(meta[word]).sort().map(s => `_${word}::${s}${dc}`)]);
          }
          for(const word of Object.keys(meta.Korok)) {
              const k = meta.Korok[word]
              if(10 in k) {
                  meta.Korok[word].Trail = []
                  for(let i = 1; i <= 10; i++)
                      meta.Korok[word].Trail.push(meta.Korok[word][i])
                  meta.Korok[word].Trail.push(meta.Korok[word])
              } else if('5' in k) {
                  meta.Korok[word].Trail = []
                  for(let i = 1; i <= 5; i++)
                      meta.Korok[word].Trail.push(meta.Korok[word][i])
                  meta.Korok[word].Trail.push(meta.Korok[word])
              }
          }
          
          NAMES = await load_json("names.json");
          myCodeMirror.setValue(txt);
          hail.check_splits()
      }
      main()
      function $div() {
          return document.createElement('div')
      }
      function $input() {
          return document.createElement('input')
      }
      function $button() {
          return document.createElement('button')
      }

      const route_el = document.getElementById('route');
      let nsegments = 1;
      let nlines = 1;
      function route_new_segment(segment_name, layer) {
          const segment = $div();
          segment.classList.add('segment')
          const title = $div();
          title.classList.add('segment_title');
          const data = $div();
          data.classList.add('segment_data');
          const txt = $div();
          txt.textContent = `${nsegments}. ${segment_name}`;
          txt.classList.add('segment_title_text')
          if(SHIFT_TITLE) {
              txt.classList.add('segment_title_text_pad')
          }
          title.appendChild(txt)

          const box = document.createElement('input')
          box.type = 'checkbox';
          box.checked = true;
          box.addEventListener('change', (ev) => {
              if(ev.target.checked) {
                  SEGMENTS[segment_name].group.invoke('addTo', map);
              } else {
                  SEGMENTS[segment_name].group.invoke('remove');
              }
          })

          const layer_div = $div();
          layer_div.classList.add('segment_title_layer');
          layer_div.textContent = layer;

          title.appendChild(box)
          title.appendChild(layer_div);
          segment.appendChild(title);

          route_el.appendChild(segment);
          segment.appendChild(data);
          nsegments += 1;
          return data;
      }

      function get_meta_item(kind) {
          if(!kind)
              return undefined
          let m = meta;
          for(const v of kind) {
              if(!v.name in m)
                  break
              m = m[v.name]
          }
          return m;
      }

      let notes_class = "even";
      function get_route_icon(kind, warp) {
          if(!kind)
              return undefined;
          if(warp)
              return meta._icons.Warp;
          let icon = meta._icons;

          if(kind.length && kind[0].sub && kind[0].sub.startsWith("- Bomb Flower")) {
              if(Math.random() * 100 > 98)
                  return icon['Item']['- Squirrel']
              return icon['Item']['- Bomb Flower']
          }
          for(let i = 0; i < kind.length; i++) {
              const v = kind[i];
              if(!(v.name in icon)) {
                  if(i+1 < kind.length && kind[i+1].name in icon)
                      icon = icon[kind[i+1].name]
                  break
              }
              icon = icon[v.name];
          }
          return icon;
      }
      function set_route_icon(ret, div) {
          let kind = get_route_icon(ret.kind, ret.warp);
          if(kind) {
              const img = new Image();
              const size = kind.routeSize;
              img.src = kind.iconUrl;
              div.appendChild(img);
              div.classList.add('segment_line_text_icon');
              if(size) {
                  img.style.width = `${size[0]}px`;
                  img.style.minWidth = `${size[0]}px`;
                  img.style.height = `${size[1]}px`
              }
          }
      }
      const template = function(templateString, templateVars){
          var func = new Function(...Object.keys(templateVars),  "return `"+templateString +"`;")
          return func(...Object.values(templateVars));
      }

      function displayString(ret) {
          const icon = get_route_icon(ret.kind, ret.warp);
          let txt = formatter(ret.txt)
          if(!icon || !icon.displayString)
              return txt
          return template(icon.displayString, {
              txt: txt, key: ret.key, meta: get_meta_item(ret.kind)
          })
      }

      function removeElementsByClass(className){
          const elements = document.getElementsByClassName(className);
          while(elements.length > 0){
              elements[0].classList.remove(className);
          }
      }

      function hide_all_segments() {
          for(const [key, segment] of Object.entries(SEGMENTS)) {
              segment.group.invoke('remove')
          }
      }

      let PROGRESS = {};
      let CURRENT_LINE = undefined;
      function set_current_line(id) {
          if(id == undefined) {
              CURRENT_LINE = undefined;
              removeElementsByClass('line_active')
              return;
          }
          const previous_line = CURRENT_LINE
          if(CURRENT_LINE !== undefined) {
              let num0  = CURRENT_LINE.split("_")[1]
              let num1  = id.split("_")[1]
              let move = num1 - num0
              if(move == 1) { // Forward by 1
                  const el = document.getElementById(CURRENT_LINE)
                  if(el.dataset.split) {
                      //console.log("SPLIT", el)
                      hail.split()
                  }
              } else if(move == -1) { // Backward by 1
                  const el = document.getElementById(id)
                  if(el.dataset.split) {
                      //console.log("UNSPLIT", el)
                      hail.unsplit()
                  }
              }
          }
          removeElementsByClass('line_active')
          const el = document.getElementById(id);
          el.classList.add('line_active');
          CURRENT_LINE = id;
          switch_layer(el.dataset.layer);
          if(el.dataset.xyz) {
              const xyz = el.dataset.xyz.split(",").map(x => parseFloat(x));
              map_el.map.panTo(ll(xyz), { animate: true } );
          }
          // This hides all segments except for the current segment
          if(ONLY_SEGMENT) {
              hide_all_segments()
              SEGMENTS[el.dataset.segment].group.invoke('addTo', map_el.map);
          }
          if(SHOW_PROGRESS) {
              let n = parseInt(id.replace("line_",""))
              const progress_update_when = document.querySelector('input[name="progress_update"]:checked').value
              if(progress_update_when == "Update after line") {
                  n -= 1
              }
              while(n >= 0) {
                  if(PROGRESS[n]) {
                      update_progress( PROGRESS[n]);
                      break;
                  }
                  n -= 1;
              }
          }
      }

      function update_progress(progress) {
          for(const key of Object.keys(progress)) {
              let el = document.getElementById(`progress_${key}`);
              if(el) {
                  if(key == 'mappct') {
                      const pct = (100 * progress[key] / 2492);
                      el.innerText = pct.toFixed(2);
                      const title = `map% ${progress[key]} / 2492 = ${pct.toFixed(5)}%`
                      el.title = title
                      document.getElementById(`progress_icon_${key}`).title = title;
                  }
                  else {
                      el.innerText = progress[key];
                  }
              }
          }
      }

      function route_new_line(part, xyz, line_layer, segment_name, split_here, _doc) {
          if(part == undefined || part == null)
              return undefined;
          //console.log(part, split_here, nlines)
          const line = $div();
          line.classList.add('segment_line')
          line.id = `line_${nlines}`;
          if(xyz !== undefined)
              line.dataset.xyz = xyz;
          line.dataset.layer = line_layer;
          line.dataset.segment = segment_name;

          // Basic Split Identifier
          const line_name = (typeof part == 'object') ? Object.keys(part)[0] : part
          let obj = {}
          if(typeof part == "object") {
              const k = Object.keys(part).filter(v => v != '_doc')
              obj = part[k]
          } else {
              obj = { text: part }
          }

          if(split_here) {
              line.dataset.split = true
          }

          line.addEventListener('click', (ev) => {
              set_current_line(ev.currentTarget.id);
          });
          const num = $div();
          num.classList.add('segment_line_number');
          num.title = `editor to line ${_doc.line_start + 1}`
          num.addEventListener('click', (ev) => {
              const line = _doc.line_start + 1
              const top = myCodeMirror.charCoords({line, ch: 0}, "local").top;
              const middle = myCodeMirror.getScrollerElement().offsetHeight / 2
              myCodeMirror.scrollTo(null, top - middle - 5)
              myCodeMirror.setCursor({line, ch:0})
          })
          num.textContent = `${nlines}`;
          if(split_here) {
              if(obj['split-type'] == "Start")
                  num.textContent += ""
              else
                  num.textContent += ""
          }
          line.appendChild(num);
          const current_line = nlines;
          nlines += 1

          const counter = $div();
          counter.classList.add('segment_line_counter');
          line.appendChild(counter);

          const text_cell = $div();
          text_cell.classList.add('segment_line_text');
          line.appendChild(text_cell);

          const text_cell_wrap = $div()
          text_cell_wrap.classList.add('segment_line_text_row')
          text_cell.appendChild(text_cell_wrap);
          const icon = $div();
          text_cell_wrap.appendChild(icon);
          const text_cell_wrap_col = $div();
          text_cell_wrap_col.classList.add('segment_line_text_column')
          text_cell_wrap.appendChild(text_cell_wrap_col);
          const text = $div();
          text.classList.add('segment_line_text_text');
          text_cell_wrap_col.appendChild(text);
          const comment = $div();
          comment.classList.add('segment_line_text_comment');
          text_cell_wrap_col.appendChild(comment);

          const notes = $div();
          notes.classList.add('segment_line_notes');
          line.appendChild(notes);
          if(typeof part == "string") {
              const ret = parse_name_to_line(part);
              const count = counter_inc(ret.kind, ret.key, ret.warp);
              if(count != undefined) {
                  if(count.count) {
                      counter.textContent = `${count.count}`;
                      counter.title = ret.kind.map(v=>v.name).join('::');
                  }
                  PROGRESS[current_line] = counter_total();
              }
              set_route_icon(ret, icon)
              text.innerHTML = displayString(ret)

              if(ret.comment)
                  comment.innerHTML = formatter(ret.comment);
              return line;
          }
          const name = Object.keys(part)[0]
          const vals = part[name];
          if(!vals)
              return undefined;
          const ret = parse_name_to_line(name);
          const count = counter_inc(ret.kind, ret.key, ret.warp);
          if(count != undefined) {
              if(count.count) {
                  counter.textContent = `${count.count}`;
                  counter.title = ret.kind.map(v=>v.name).join('::');
              }
              PROGRESS[current_line] = counter_total();
          }
          set_route_icon(ret, icon)
          text.innerHTML = displayString(ret);
          if(vals.notes) {
              notes.innerHTML = formatter(vals.notes);
              notes.classList.add(notes_class);
              notes_class = (notes_class == "even") ? "odd" : "even";
          }
          if(ret.comment)
              comment.innerHTML = formatter(ret.comment);
          else if(vals.comment)
              comment.innerHTML = formatter(vals.comment);

          return line;
      }

      function switch_layer(level) {
          if(level == map_el.level)
              return;
          map_el.map.removeLayer(baseMapLayers[map_el.level])
          baseMapLayers[level].addTo(map_el.map);
          map_el.level = level;
      }

      map_el.map.on('baselayerchange', (ev) => {
          switch_segments(ev.name);
          map_el.level = ev.name;
      });

      function get_next_line(dir) {
          if(CURRENT_LINE === undefined)
              return undefined;
          //console.log('CURRENT LINE', CURRENT_LINE);
          let n = parseInt(CURRENT_LINE.split("_")[1]);
          if(n === undefined) {
              console.log("could not get line number", CURRENT_LINE);
              return undefined;
          }
          n += dir;
          let next_id = `line_${n}`;
          let next = document.getElementById(next_id);
          if(!next) {
              //console.log("could not find next line", next_id);
              return undefined;
          }
          return next;
      }

      function scroll_to_line(id) {
          //console.log("SCROLL", id)
          const next = document.getElementById(id);
          const route = document.getElementById('route')
          const xoffset = 0;
          const yoffset = next.offsetTop - route.offsetTop - 40;
          route.scrollTo(xoffset, yoffset)
          set_current_line(next.id);
      }

      function toggle_search() {
          SEARCH = ! SEARCH;
          const set = document.getElementById('search0')
          set.style.display = (SEARCH) ? 'block' : 'none'
      }
      function toggle_only_segment() {
          ONLY_SEGMENT = ! ONLY_SEGMENT;
          if(!ONLY_SEGMENT) {
              switch_segments(map_el.level);
          }
          set_current_line(CURRENT_LINE);
          return;
      }
      function toggle_report_splits() {
          REPORT_SPLITS = ! REPORT_SPLITS
          const el = document.getElementById('split_status')
          el.style.display = (REPORT_SPLITS) ? "flex" : "none"
      }
      function toggle_show_progress() {
          SHOW_PROGRESS = ! SHOW_PROGRESS;
          const el = document.getElementById("progress0");
          el.style.display = (SHOW_PROGRESS) ? 'block' : 'none';
          set_current_line(CURRENT_LINE);
      }
      function toggle_shift_title() {
          SHIFT_TITLE = ! SHIFT_TITLE;
          set_current_line(CURRENT_LINE);
          const ele = document.getElementsByClassName('segment_title_text');
          for(const el of ele) {
              if(SHIFT_TITLE) {
                  el.classList.add('segment_title_text_pad')
              } else {
                  el.classList.remove('segment_title_text_pad')
              }
          }
      }

      function is_last_line(dir) {
          if(CURRENT_LINE == undefined)
              return false
          let n = parseInt(CURRENT_LINE.split("_")[1])
          if(n === undefined)
              return false
          if(dir < 0)
              return false
          n += dir
          let next_id = `line_${n}`
          const next = document.getElementById(next_id)
          if(!next)
              return true
          return false
      }

      function key_commands(ev) {
          if(ev.ctrlKey && ev.key == "p") {
              return toggle_show_progress()
          }
          if(ev.ctrlKey && ev.key == "o") {
              return toggle_only_segment()
          }
          if(ev.ctrlKey && ev.key == "j") {
              return toggle_search()
          }
          if(ev.ctrlKey && ev.key == "i") {
              return toggle_shift_title()
          }
          if(ev.ctrlKey && ev.key == "g") {
              SETTINGS = ! SETTINGS
              const set = document.getElementById('settings')
              set.style.display = (SETTINGS) ? 'block' : 'none'
              ev.stopPropagation()
              ev.preventDefault()

              return false;
          }
          if(CURRENT_LINE === undefined)
              return
          if(ev.key == "ArrowDown" || ev.key == "ArrowUp") {
              let dir = (ev.key == "ArrowDown") ? 1 : -1
              let next = get_next_line(dir);
              if(next === undefined) {
                  if(is_last_line(dir)) {
                      const el = document.getElementById(CURRENT_LINE)
                      if(el.dataset.split == "true") {
                          console.log("SPLIT", el)
                          hail.split()
                      }
                  }
                  return;
              }
              scroll_to_line(next.id)
              ev.stopPropagation()
              ev.preventDefault()
              return false;
          }
      }
      window.addEventListener('keydown', key_commands);
      </script>
    <script type="module">
      import { lss_splits } from './lss.js'
      console.log('splits_lss', lss_splits)
      document.getElementById('splits_lss_button').addEventListener('click', (ev) => {
          const txt = lss_splits(SPLITS.game_title, SPLITS.category, SPLITS.splits)
          const blob = new Blob([txt], { type: 'application/lss' })
          const a = document.createElement('a')
          let description = "totk_celer_route";
          if(data._project && data._project.description) {
              description = data._project.description;
          } else if (data._project && data._project.name) {
              description = data._project.name;
          }
          description = description.replaceAll(" ", "_").replaceAll(",","")
          let when = new Date().toISOString().replace(/.\d+Z$/g, "") // Remove milliseconds
          a.href = URL.createObjectURL(blob);
          a.download = `${description}_splits_${when}.lss`;
          a.click();

      })

    </script>
  </body>
</html>
