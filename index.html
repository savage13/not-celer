<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="leaflet/leaflet.css" />
    <script src="leaflet/leaflet.js"></script>
    <link rel="stylesheet" href="leaflet/L.Control.MousePosition.css" />
    <script src="leaflet/L.Control.MousePosition.js"></script>
    <link rel="stylesheet" href="codemirror/addon/hint/show-hint.css">
    <script src="codemirror/lib/codemirror.js"></script>
    <link rel="stylesheet" href="codemirror/lib/codemirror.css">
    <script src="codemirror/mode/yaml/yaml.js"></script>
    <script src="codemirror/addon/hint/show-hint.js"></script>
    <link rel="stylesheet" href="codemirror/theme/base16-dark.css">
    <link rel="stylesheet" href="codemirror/theme/base16-light.css">
    <script src="leaflet.geometryutil.js"></script>
	  <script src="leaflet-arrowheads.js"></script>
    <script src="js-yaml.js"></script>
    <script src="leaflet-canvasicon.js" defer></script>
    <script src="debounce.js"></script>
    <!--
BSD 2-Clause License

Copyright (c) 2023, savage13@gmail.com

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

      -->
    <title>Not Celer (TotK)</title>
    <style>
      body {
          margin: 0;
          padding: 0;
      }
      #map {
          display: block;
          height: 100%;
          width: 100%;

      }
      #map0 {
          position: relative;
          width: 100%;
          height: 100%;
      }
      .CodeMirror {
          height: 100%;
          width: 100%;
      }
      #wrap {
          position: relative;
          width: 100%;
          display: flex;
          height: 100%;
          background: rgba(0,0,0,0.85);
      }
      #messages {
          position: absolute;
          display: none;
          left: 0;
          bottom: 0;
          width: 100%;
          font-family: sans-serif;
          background: rgba(0,0,0,0.7);
          color: white;
          min-height: 7em;
          padding: 1em;
          overflow: scroll;
      }
      #messages div pre {
          padding:0;
          margin: 0;
      }
      #messages button {
          cursor: pointer;
          position: relative;
          pointer-events: all;
      }
      .split {
          display: flex;
          flex-direction: row;
          height: 100vh;
          width: 100vw;
      }
      .gutter {
          background-color: #eee;
          background-repeat: no-repeat;
          background-position: 50%;
      }
      .gutter.gutter-horizontal {
          background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==');
          cursor: col-resize;
      }
      #route0 {
          position: relative;
          padding-top: 0.5em;
          padding-right: 0.0em;
          padding-bottom: 0.2em;
          background: black;
      }
      #route {
          width: 100%;
          height: 100%;
          overflow: scroll;
          background: black;
      }
      .segment {
          width: 100%;
      }
      .segment_data {
          display: table;
          table-layout: fixed;
          width: 100%;
      }
      .segment_title {
          font-family: sans-serif;
          background: black;
          color: yellow;
          font-size: 1.2em;
          display: flex;
          height: inherit;
          flex-flow: row nowrap;
      }
      .segment_title_layer {
          color: white;
          font-size: 0.7em;
          height: 100%;
          vertical-align: bottom;
          margin-left: auto;
          margin-right: 1em;
          margin-top: auto;
          margin-bottom: auto;
      }
      .segment_line {
          display: table-row;
          background: black;
          color: white;
          font-family: sans-serif;
          font-size: 0.9em;
          width: 100%;
      }
      .segment_line > div {
          padding: 0.2em;
          border-bottom: 1px solid rgba(255,255,255,0.2);
          border-left: 1px solid rgba(255,255,255,0.1);
      }
      .segment_line_number {
          border: 0px solid gray;
          display: table-cell;
          width:3em;
          vertical-align: top;
      }
      .segment_line_counter {
          border: 0px solid gray;
          display: table-cell;
          width:3em;
          vertical-align: top;
      }
      .segment_line_text {
          border: 0px solid gray;
          display: table-cell;
          min-width: 10em;
      }
      .segment_line_text_text {
          display: table-cell;
      }
      .segment_line_text_row {
          display: flex;
          flex-flow: row nowrap;
      }
      .segment_line_text_icon {
          width: 50px;
          min-width: 50px;
          height: 24px;
          text-align: center;
      }
      .segment_line_text_icon img {
          width: 100%;
          height: 100%;
      }
      .segment_line_text_column {
          display: flex;
          flex-flow: column nowrap;
          width: 100%;
      }
      .segment_line_text_comment {
          display: table-cell;
          vertical-align: top;
          font-size:0.9em;
          color: #cccccc
      }
      .even {
          color: black;
          background: #CCCCFB;
      }
      .odd {
          color: black;
          background: #EEC652;
      }
      .segment_line_notes {
          border: 0px solid gray;
          display: table-cell;
          max-width: 20%;
          vertical-align: top;
      }

      #missing_stub {
          cursor: pointer;
          font-family: sans-serif;
          font-size: 0.8em;
          color: white;
          padding: 0.5em;
          text-align: right;
          margin-right: 2em;
          opacity: 1;
      }
      #missing_stub:hover {
          color: lightblue;
      }
      #missing {
          font-family: sans-serif;
          position: absolute;
          bottom: 0;
          width: 98%;
          left: 0;
          display: flex;
          flex-flow: column nowrap;
          background: rgba(0,0,0,0.0);
          color: white;
          padding-left: 1em;
          padding-right: 1em;
          padding-top: 0.1em;
          padding-bottom: 0.1em;

      }
      #missing_data {
          overflow: scroll;
          height: 0px;
      }
      #missing_down {
          display:none;
      }
      #missing_up {
          display:inline;
      }
      .missing_show_hide {
          display: inline;
          font-size: 0.8em;
          cursor: pointer;
          vertical-align:middle;
          height: 100%;
      }
      .missing_show_hide:hover {
          color: lightblue;
      }
      .missing_summary {
          display: inline;
          width: 100%;
      }
      .missing_summary_box {
          display: inline-flex;
          flex-flow: row nowrap;
          width: 90%;
          align-items: center;
          justify-content: space-between;
      }
      summary {
          width: 100%;
      }
      summary:hover {
          background: rgba(30,30,30,0.8);
      }
      #theme {
          position: absolute;
          bottom: 0;
          right: 0;
          display: flex;
          flex-flow: row nowrap;
      }
      #search0 {
          position: absolute;
          z-index: 40000;
          bottom: 0;
          left: 0;
          background: rgba(0,0,0,0.4);
          padding: 0.5em;
          border: 0.5px solid rgba(255,255,255,0.3);
          border-radius: 0.3em;
          color: white;
      }
      #search0 input {
          background: inherit;
          color: inherit;
          width: 15em;
          border: 1px solid white;
          padding: 0.3em;
          border-radius: 0.3em;
      }
      #progress0 {
          position: absolute;
          z-index: 40000;
          top: 0;
          left: 50%;
          transform: translate(-50%,0) scale(0.75);
          background: rgba(0,0,0,1);
          color: lightblue;
          border: 0.5px solid rgba(255,255,255,0.3);
          border-radius: 0.3em;
          display: none;
      }
      #progress {
          font-family: sans-serif;
          padding: 0.3em;
      }
      #progress div {
          cursor: default;
      }
      #progress div img {
          width: 30px;
          height: 30px;
      }
      .itiny {
          font-style: italic;
          font-size: 0.7em;
      }
      .line_active {
          background: #f9f0c4;
          color: black;
      }
      .table {
          display: table;
      }
      .tr {
          display: table-row;
      }
      .td {
          display: table-cell;
          text-align: center;
          vertical-align: middle;
          padding-left: 0.2em;
          padding-right: 0.2em;
      }
    </style>
  </head>
  <body>
    <div id="app" class="split">
      <div id="wrap">
        <textarea id="editor"></textarea>
        <div id="messages"></div>
        <div id="theme">
          <button id="save">Save</button>
          <select id="themes">
            <option value="base16-dark">Dark</option>
            <option value="base16-light">Light</option>
          </select>
        </div>
      </div>
      <div id="route0">
        <div id="route"></div>
        <div id="missing">
          <div id="missing_stub">
            <div id="missing_up">&#9650;</div>
            <div id="missing_down">&#9660;</div>
            Missing Items</div>
          <div id="missing_data"></div>
        </div>
      </div>
      <div id="map0">
        <div id="map" game="totk"></div>
        <div id="search0">
          <input type="text" placeholder="Search objmap..." id="search">
        </div>
        <div id="progress0">
          <div id="progress" class="table">
            <div class="tr">
              <div class="td"><img src="tower.png"></div>
              <div class="td"><img src="shrine.png"></div>
              <div class="td"><img src="lightroot.png"></div>
              <div class="td"><img src="frog.png"></div>
              <div class="td"><img src="mapicon_korok.png"></div>
              <div class="td"><img src="sign.png"></div>
              <div class="td"><img src="cave.png"></div>
              <div class="td"><img src="well.svg"></div>
              <div class="td"><img src="talus.png"></div>
              <div class="td"><img src="gleeok.png"></div>
              <div class="td"><img src="hinox.png"></div>
              <div class="td"><img src="frox.png"></div>
              <div class="td"><img src="molduga.png"></div>
              <div class="td"><img src="flux.png"></div>
              <div class="td" id="progress_icon_mappct"><img src="World_Map.png"></div>
            </div>
            <div class="tr">
              <div class="td" id="progress_Tower">0</div>
              <div class="td" id="progress_Shrine">0</div>
              <div class="td" id="progress_Lightroot">0</div>
              <div class="td" id="progress_Bubbulfrog">0</div>
              <div class="td" id="progress_Korok">0</div>
              <div class="td" id="progress_Addison">0</div>
              <div class="td" id="progress_Cave">0</div>
              <div class="td" id="progress_Well">0</div>
              <div class="td" id="progress_Enemy::Talus">0</div>
              <div class="td" id="progress_Enemy::Gleeok">0</div>
              <div class="td" id="progress_Enemy::Hinox">0</div>
              <div class="td" id="progress_Enemy::Frox">0</div>
              <div class="td" id="progress_Enemy::Molduga">0</div>
              <div class="td" id="progress_Enemy::FluxConstruct">0</div>
              <div class="td" id="progress_mappct">0</div>
            </div>
          </div>
        </div>
          <!-- <zelda-map id="map" game="totk"></zelda-map>-->
      </div>
    </div>
    <script src="split.min.js"></script>
    <script>
      let sizes = localStorage.getItem('split-sizes')
      if(sizes)
          sizes = JSON.parse(sizes);
      else
          sizes = [20, 30, 50];
      Split([ '#wrap', '#route0','#map0'], {
          sizes: sizes,
          minSize: [0, 0, 300],
          onDragEnd: function (sizes) {
              localStorage.setItem('split-sizes', JSON.stringify(sizes))
          },
      })
      document.getElementById('missing_stub').addEventListener('click', (ev) => {
          const md = document.getElementById('missing_data')
          const h = md.offsetHeight;
          const up = document.getElementById('missing_up');
          const dn = document.getElementById('missing_down');
          const ms = document.getElementById('missing');
          if(h > 100) {
              md.style.height = '0px';
              style="display: inline;"
              up.style.display = 'inline';
              dn.style.display = 'none';
              ms.style.background = 'rgba(0,0,0,0)';
          } else {
              md.style.height = '200px';
              up.style.display = 'none';
              dn.style.display = 'inline';
              ms.style.background = 'rgba(0,0,0,0.8)';
          }

      });
    </script>

    <script type="text/javascript" defer>
      const game = "totk";

      const map_options = {
          TILE_SIZE: 256,
          MAP_SIZE: [24_000, 20_000],
          DEFAULT_ZOOM: 5,
          MIN_ZOOM: 1,
          MAX_ZOOM: 12,
      }
      const crs = L.Util.extend({}, L.CRS.Simple);
      // @ts-ignore
      crs.transformation = new L.Transformation(
          4 / map_options.TILE_SIZE,
          map_options.MAP_SIZE[0] / map_options.TILE_SIZE,
          4 / map_options.TILE_SIZE,
          map_options.MAP_SIZE[1] / map_options.TILE_SIZE);

      let map_el = {};

      const map_ele = document.getElementById('map');
          const map = new L.Map(map_ele, {
              attributionControl: false,
              zoom: map_options.DEFAULT_ZOOM,
              minZoom: map_options.MIN_ZOOM,
              maxZoom: map_options.MAX_ZOOM,
              maxBoundsViscosity: 1.0,
              crs,
              preferCanvas: true,
          })
          //L.control.attribution({ prefix: false }).addTo(map);
      map_el = {
          map: map,
          level: "Surface",
      }

      // from leaflet-rastercoords
      const zoomLevel = Math.ceil(
          Math.log(Math.max(map_options.MAP_SIZE[0], map_options.MAP_SIZE[1]) / map_options.TILE_SIZE) / Math.log(2)
      );
      var sW = map.unproject([0, map_options.MAP_SIZE[1]], zoomLevel);
      var nE = map.unproject([map_options.MAP_SIZE[0], 0], zoomLevel);
      map.setMaxBounds(L.latLngBounds(sW, nE));

      map.setView([0, 0], 3);
      const TOTK_MAP = "https://objmap-totk.zeldamods.org/game_files/map";
      const BOTW_MAP = "https://objmap.zeldamods.org";
      const AREAS = ["Sky", "Surface", "Depths"];

      const baseMapLayers = {};

      if (game == "totk") {
          for (const area of AREAS) {
              const zarea = (area == "Surface") ? "Ground" : area;
              baseMapLayers[area] = L.tileLayer(`${TOTK_MAP}/${zarea}/maptex/{z}/{x}/{y}.webp`, {
                  attribution: '<a href="https://objmap-totk.zeldamods.org/">Zeldamods Object Map</a>',
                  maxNativeZoom: 7,
              });
          }
          if (!(map_el.level in baseMapLayers))
              map_el.level = "Surface";
          baseMapLayers[map_el.level].addTo(map_el.map);
          L.control.layers(baseMapLayers).addTo(map_el.map);
      }

      L.control.mousePosition({
          lngFirst: true,
          position: 'bottomright',
          latFormatter: (x => (-x).toFixed(2)),
          lngFormatter: (x => (x).toFixed(2)),
      }).addTo(map_el.map);

      let data = undefined;

      const msg_el = document.getElementById('messages');

      function warn(msg) {
          msg_el.style.display = 'block';
          msg_el.innerHTML += `<div>${msg}</div>`
          console.log(msg);
      }

      function switch_segments(layer) {
          //console.log(map_el.map);
          Object.values(SEGMENTS).forEach(seg => {
              if(seg.layer == layer) {
                  //console.log(seg.group.getLayers());
                  seg.group.invoke('addTo', map_el.map)
              } else {
                  seg.group.invoke('remove')
              }
          });
      }

      const completions = [
      ]

      let COMPS = L.layerGroup();

      function meta_from_names(items) {
          return items.map(x => meta_get(x))
      }
      function synonyms(cm, option) {
          return new Promise(function(accept) {
              setTimeout(function() {
                  var cursor = cm.getCursor(), line = cm.getLine(cursor.line)
                  var start = cursor.ch, end = cursor.ch
                  while (start && /[A-Za-z0-9_:]/.test(line.charAt(start - 1))) --start
                  while (end < line.length && /[A-Za-z0-9_:]/.test(line.charAt(end))) ++end
                  const word = line.slice(start, end);
                  const k = word.lastIndexOf("::");
                  if(k == -1) {
                      console.log('accept null early')
                      return accept(null)
                  }
                  const prefix = word.slice(0,k+2);
                  //console.log('autocomplete', word, prefix);
                  const comp = completions;
                  for (var i = 0; i < comp.length; i++) {
                      if (comp[i].indexOf(prefix) != -1) {
                          const items = comp[i]
                                .filter(w => w.startsWith(word))
                                .filter(x => {
                                    let tmp = x.replace(/^_/, "")
                                    return !counter_has(tmp);
                                });
                          const data = {
                              list: items,
                              from: CodeMirror.Pos(cursor.line, start),
                              to: CodeMirror.Pos(cursor.line, end)
                          };
                          const meta_items = items
                                .map(x => x.replace(/^_/, ""))
                                .map(x => [x, meta_get(x)])
                                .filter(x => x[0] && x[1])
                                .map(m => L.circleMarker(ll(m[1].pos), {
                                    color: '#ff2c00', radius: 7
                                }).bindTooltip(m[0]));
                          COMPS.invoke('remove');
                          COMPS.clearLayers();
                          meta_items.forEach(m => COMPS.addLayer(m));
                          CodeMirror.on(data, 'shown', () => {
                              COMPS.invoke('addTo', map_el.map);
                          });
                          CodeMirror.on(data, 'close', () => {
                              COMPS.invoke('remove');
                          });
                          return accept(data);
                      }
                  }
                  console.log('accept null')
                  return accept(null)
              }, 100)
          })
      }

      let theme = localStorage.getItem('theme') || 'base16-dark';
      localStorage.setItem('theme', theme);


      const myCodeMirror = CodeMirror.fromTextArea(
          document.getElementById('editor'), {
              lineNumbers: true,
              mode: 'yaml',
              extraKeys: {"Tab": "autocomplete"},
              hintOptions: {
                  hint: synonyms,
                  shown: function()  {
                      console.log('show hints shown')
                  },
                  close: function()  {
                      console.log('show hints closed')
                  }
              },
              theme: theme,
          });

      document.getElementById('themes').addEventListener('change', (ev) => {
          const theme = ev.target.value;
          localStorage.setItem('theme', theme);
          myCodeMirror.setOption("theme", theme);
      });

      document.getElementById('save').addEventListener('click', (ev) => {
          let txt = myCodeMirror.getValue();
          const blob = new Blob([txt], { type: 'application/x-yaml' })
          const a = document.createElement('a')
          let description = "totk_celer_route";
          if(data._project && data._project.description) {
              description = data._project.description;
          } else if (data._project && data._project.name) {
              description = data._project.name;
          }
          description = description.replaceAll(" ", "_").replaceAll(",","")
          let when = new Date().toISOString().replace(/.\d+Z$/g, "") // Remove milliseconds
          a.href = URL.createObjectURL(blob);
          a.download = `${description}_${when}.yaml`;
          a.click();
      });

      function get_name(name) {
          return NAMES[name] || name
      }
      const search_debounce = debounce(search, 250)
      const OBJMAP_MARKERS = L.layerGroup();
      const TOTK_URL = "https://radar-totk.zeldamods.org/objs/MainAndMinusField/?q=";
      // =seeds&withMapNames=false&limit=2000
      async function search(value) {
          if(value.trim() == ""){
              OBJMAP_MARKERS.invoke('remove')
              OBJMAP_MARKERS.clearLayers();
          }
          const url = `${TOTK_URL}${value}&withMapNames=false&limit=2000`;
          let objs;
          try {
              const res = await fetch(url);
              objs = await res.json();
          } catch(e) {
              warn(e);
              return;
          }
          OBJMAP_MARKERS.invoke('remove')
          OBJMAP_MARKERS.clearLayers();
          for(const obj of objs) {
              const name = get_name(obj.name);
              const m = L.circleMarker(
                  [obj.pos[2],obj.pos[0]],
                  {radius: 6, color: '#ff2222'})
                    .bindTooltip(`<div>${name}</div><div class="itiny">Click marker to copy position</div>`)
                    .addTo(map_el.map)
                    .on('click', (ev) => {
                        const pos = `[${obj.pos[0]}, ${obj.pos[1]}, ${-obj.pos[2]}]`;
                        navigator.clipboard.writeText(pos);

                    });
              OBJMAP_MARKERS.addLayer(m);
          }
      }
      document.getElementById('search').addEventListener('input', (ev) => {
          search_debounce(ev.target.value)
      });
      function set_route(txt) {
          localStorage.setItem("route.txt", txt)
      }
      function get_route() {
          return localStorage.getItem("route.txt")
      }
      let NOW = true;
      const route_debounce = debounce(route_update, 1000);
      function route_update(txt) {
          let tmp_data;
          try {
              tmp_data = jsyaml.load(txt); // Convert yaml to json
              xclear();   // Clears map and route
              data = tmp_data; // Save parsed data to global data variable, eeek!
              set_route(txt); // Saves route text to localStorage
              route(); // Draws map and route
          } catch(e) {
              msg_clear();
              console.log(e);
              warn('Parse Error')
              e.message.split("\n").forEach(msg => warn(`<pre>${msg}</pre>`));
          }
      }

      myCodeMirror.on('change', (instance, changeObj) => {
          const txt = instance.getValue();
          if(NOW) {
              route_update(txt);
              NOW = false;
              return
          }
          route_debounce(txt);
      });

      function save_metadata() {
          const blob = new Blob([JSON.stringify(meta, null, 2)], { type: 'application/json' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'celer_botw_metadata.json',
          a.click();
      }

      function ll(pt) {
          const n = pt.length;
          if(n == 3)
              return [pt[n-1], pt[0]]
          warn('Expected  3 points, got', n);
          return []
      }

      // Read raw coordinates (not from data files)
      //  - in format [E-W, U-D, N-S]
      //  - objmap report North as positive
      //  - in reality North is negative for the actual data
      //    - data files reported from radar are already as North negative
      //    - objmap flips the North-South values for display only
      function read_xyz(v) {
          if(v == undefined)
              return undefined
          return [v[0], v[1], -v[2]]
      }

      function get_map_icon(kind, n = undefined) {
          if(n <= 0 || kind == undefined)
              return undefined;
          n = (n !== undefined) ? n : kind.length;
          const key = kind.slice(0,n).map(v => v.name).join("::");
          let icon = icons[key];
          if(!icon) {
              if(n-2 >= 0) {
                  // Remove 2nd to last element to check for
                  //  Shrine::*::Start
                  //  Korok::*::Start
                  //  Korok::*::End
                  //  There is a better solution, but this works
                  let tmp = [...kind];
                  tmp.splice(n-2,1)
                  let key1 = tmp.map(v => v.name).join("::")
                  if(icons[key1])
                      return icons[key1]
              }
              return get_map_icon(kind, n - 1)
          }
          return icon
      }

      function marker(kind, pt, name, warp = false) {
          let icon = get_map_icon(kind);
          if(icon)
              return L.marker(ll(pt), { icon: icon }).bindTooltip(name);
          return L.circleMarker(ll(pt)).bindTooltip(name);
      }

      function parse_name_to_line(name) {
          const name_orig = name;
          if(name[0] != "_") {
              return {txt: name};
          }
          name = name.slice(1)
          let v = name.split('::');
          let warp = false;
          if(v[0] == "Warp") {
              warp = true;
              v = v.slice(1);
          }
          let m = meta;
          let sub = undefined;
          let ele = "";
          let kind = []
          for(const el of v) {
              const k = el.indexOf("<");
              ele = (k != -1) ? el.slice(0,k) : el;
              if(m[ele])
                  m = m[ele]
              else {
                  m = undefined;
                  break
              }
              let val = el;
              sub = undefined ;
              if(k != -1) {
                  sub = el.slice(k+1,-1);
                  if(sub.match(/^[-+0-9., ]+$/)) {
                      //pos = sub.split(",").map(x => parseFloat(x));
                      sub = "";
                  }
                  val = el.slice(0,k);
              }
              kind.push({ name: val, sub })
          }
          if(!m) {
              warn(`Error finding metadata for ${name_orig}`);
              m = {}
          }
          if(sub) {
              if(!sub.includes(",")) {
                  return {txt: sub, kind, warp, key: ele}
              }
              v = sub.split(",",2).map(x => x.trim());
              return {txt: v[0], comment: v[1], kind, warp, key: ele}
          }
          if(m.DisplayName)
              return {txt: m.DisplayName, kind, warp, key: ele }
          if(m.Id)
              return {txt: m.Id, kind, warp, key: ele }
          return {txt: name_orig, warp, key: ele, kind}
      }

      function parse_name(name, pos = undefined) {
          const name_orig = name;
          if(name[0] == '_') {
              //return {markers: [], to: []};
              name = name.slice(1);
          } else {
              return {to: [], markers: []}
          }
          //console.log(name, pos);
          let v = name.split('::');
          let warp = false;
          if(v[0] == "Warp") {
              warp = true;
              v = v.slice(1);
          }
          let n = (v.length > 1) ? v.length - 1 : v.length;
          let kind = [];
          let m = meta;
          let sub = undefined;
          for(const el of v) {
              const k = el.indexOf("<");
              const ele = (k != -1) ? el.slice(0,k) : el;
              if(m[ele])
                  m = m[ele]
              else {
                  m = undefined;
                  break
              }
              let val = el;
              if(k != -1) {
                  sub = el.slice(k+1,-1);
                  if(sub.match(/^[-+0-9., ]+$/)) {
                      pos = read_xyz( sub.split(",").map(x => parseFloat(x)) )
                  }
                  val = el.slice(0,k);
              }
              kind.push({name: val, sub })
          }
          if(!m) {
              warn(`Error finding metadata for ${name_orig}`);
              m = {}
          }
          if(!m.pos && !pos) {
              //warn(`Metadata for ${name_orig} lacks a pos field or location not set`)
              //console.log("Metadata for ", v, " lacks a pos field or location not set");
              return {markers: [], to: []};
          }
          if(m.pos && !pos)
              pos = m.pos;
          const to = (warp) ? [[], pos]: [pos];
          const markers = [ marker(kind, pos, v[v.length-1], warp)]

          return {to, markers, icon: kind, keys: v[v.length-1] }
      }

      function parse_movements(moves) {
          const marker_states = ['all', 'start', 'end']
          let marker = 'end';
          const to = [];
          const away = [];
          for(const v of moves) {
              if(v.marker) {
                  let value = v.marker.toLowerCase();
                  if(marker_states.includes(value)) {
                      marker = value
                  } else
                      warn(`Unknown movement marker value: ${v.marker} [${marker_states}]`)
                  continue
              }
              if(v.to === undefined)
                  continue
              let pos = read_xyz(v.to);
              if(v.warp === true && v.away == true) {
              } else if(v.away == true && !v.warp) {
                  if(to.length)
                      away.push([to.at(-1), pos])
                  else
                      away.push([pos]);
              } else if(v.warp == true && !v.away) {
                  to.push([])
                  to.push(pos);
              } else {
                  to.push(pos)
              }
          }
          return {to, marker, away }
      }

      function parse_object_header(obj, keys) {
          let to = [];
          let markers = [];
          let pos = undefined;
          let icon = undefined;
          let has_movement = false;
          if(!obj[keys])
              return {to, markers}
          if(obj[keys]['hide-icon-on-map'] || keys.startsWith('_Tod::')) {
              return {to, markers}
          }
          if(obj[keys]['movements'])
              has_movement = true;

          // Find possible position
          if(obj[keys]['coord'])
              pos = read_xyz(obj[keys]['coord'])
          else if(obj[keys].movements && obj[keys].movements.some(m => m.to)) {
              const p = obj[keys].movements.find(m => m.to);
              pos = read_xyz(p.to)
          }
          // Find Icon
          if(obj[keys].icon && pos)
              return { to: [pos], markers: [marker(obj[keys].icon,pos,keys, false)],
                       icon: obj[keys].icon, keys
                     }
          //console.log("Parse name", keys, pos);
          const ret = parse_name(keys, pos);
          if(ret.to.length == 0)
              warn(`No coord: or movement::to: found for ${JSON.stringify(obj)}`)
          if(has_movement) {
              ret.markers = [];
              ret.to = [];
          }
          return ret;
      }
      function capitalize(str) {
          if(!str)
              return undefined;
          return str.charAt(0).toUpperCase() + str.slice(1);
      }
      function parse_object(obj) {
          let keys = Object.keys(obj);
          if(keys.length != 1) {
              console.log("Keys > 1");
              return [];
          }
          const to = []
          const away = [];
          const markers = [];
          let marker_icon = undefined;
          let marker_keys = undefined;
          keys = keys[0]
          if(keys[0] == "_") {
              const ret = parse_object_header(obj, keys);
              to.push(...ret.to);
              markers.push(...ret.markers);
              //console.log(ret);
              marker_icon = ret.icon;
              marker_keys = ret.keys;
          }
          const vals = Object.values(obj)[0];
          if(vals === undefined || vals === null)
              return {to, markers, away}
          let line_color = undefined;
          let level_set = undefined;
          for(const [key, val] of Object.entries(vals)) {
              if(key == "movements") {
                  const ret = parse_movements(val);
                  to.push(... ret.to);
                  const n = ret.to.length;
                  if(ret.marker == 'start' && n) {
                      markers.push( marker(marker_icon, ret.to[0], marker_keys))
                  } else if(ret.marker == 'end' && n) {
                      markers.push( marker(marker_icon, ret.to[n-1], marker_keys))
                  } else if(ret.marker == 'all' && n) {
                      markers.push( ... ret.to.map(pt => marker(marker_icon, pt, marker_keys)))
                  }
                  if(ret.away.length) {
                      away.push(...ret.away)
                      if(marker_icon) {
                          markers.push( ... ret.away.map(pt => marker(marker_icon, pt.at(-1), marker_keys)))
                      }
                  }
              } else if (key == "comment") {
              } else if (key == "line-color") {
                  line_color = val;
              } else if (key == "level") {
                  const tmp = capitalize(val);
                  if(AREAS.includes(tmp))
                      level_set = val;
                  else if(tmp == "Ground")
                      level_set = "Surface"
                  else
                      warn(`Unknown level: ${val} [${AREAS}]`)
              } else if (key == "hide-icon-on-map") {
              } else if (key == "notes") {
              } else if (key == "icon") {
              } else if (key == "gale") {
              } else if (key == "fury") {
              } else if (key == "split-type") {
              } else if (key == "time-override") {
              } else if (key == "coord") {
                  if(val.length != 3) {
                      warn(`Expected [EW, UD, NS], got a length of ${val.length}`)
                  } else {
                      val[2] = -val[2];
                  }
                  to.push( val )
              } else {
                  console.log("unexpected object key", key, vals);
              }
          }
          //console.log(to);
          return {to, markers, line_color, level: level_set, away}
      }

      let SEGMENTS = {};

      function msg_clear() {
          msg_el.innerHTML = "";
          const but = document.createElement('button');
          but.innerHTML = 'Dismiss';
          but.id = "dismiss";
          msg_el.appendChild(but);
          msg_el.style.display = 'none';
          but.addEventListener('click', msg_clear)
          msg_el.addEventListener('click', (ev) => {
              if(ev.target.id == "dismiss") {
                  msg_clear();
              }
          });
      }

      let _counters = {
          Korok: {},
          Shrine: {},
          Lightroot: {},
          Addison: {},
          Tower: {},
          Bubbulfrog: {},
          Cave: {},
          Well: {},
          Dispenser: {},
          Fairy: {},
          Tear: {},
          Tablet: {},
          Special: {},
          Shop: {},
          Temple: {},
          Location: {},
          'Enemy::Talus': {},
          'Enemy::Gleeok': {},
          'Enemy::Hinox': {},
          'Enemy::Frox': {},
          'Enemy::Molduga': {},
          'Enemy::FluxConstruct': {},
          'mappct': {},
      };
      function counter_reset() {
          Object.keys(_counters).forEach(k => {_counters[k] = {};});
      }
      function sum(vals) {
          return vals.reduce((partialSum, a) => partialSum + a, 0);
      }

      function counter_total() {
          const out = {};
          for(const [key, value] of Object.entries(_counters)) {
              out[key] = sum(Object.values(value))
          }
          return out;
      }

      function counter_has(key) {
          const v = key.split("::");
          const name = v.pop();
          key = v.join("::");
          return key in _counters && name in _counters[key];
      }

      function counter_mappct_flag(flag) {
          if(!flag || !(flag in mappct_flag))
              return
          let added = 0
          for(const item of mappct_flag[flag]) {
              _counters.mappct[item.hash_id[0]] = 1;
              added += 1
          }
      }
      function counter_inc(key, name, warp) {
          if(warp)
              return undefined
          if(!key)
              return undefined;
          if(key[key.length-1].name == 'Start')
              return undefined;
          if(key[key.length-1].name == 'End') {
              key.pop()
              if(name == 'End') {
                  name = key[key.length-1].name
              }
          }
          key = key.slice(0,-1).map(k => k.name).join('::')
          if(key in _counters) {
              { // mappct
                  const tmp = [key,name].join("::")
                  const m = meta_get(tmp);
                  if(m && m.mappct) {
                      counter_mappct_flag(m.mappct.flag)
                      counter_mappct_flag(m.mappct.flag_alt)

                  } else if(m) {
                  } else {
                      console.log("Error finding meta data", tmp)
                  }
              }
              if(name in _counters[key])
                  warn(`Duplicate of ${key} ${name}`)
              _counters[key][name] = 1;
              if(key == 'Korok') {
                  const korok = meta[key][name];
                  if(korok && korok.korok_type == "Korok Friends")
                      _counters[key][name] += 1;
              }
              return sum( Object.values(_counters[key]) );
          }
          if(key !== undefined) {
              //console.log('unknown counter', key, name);
          }
          return undefined;
      }

      function xclear() {
          msg_clear();
          route_el.innerHTML = "";
          Object.values(SEGMENTS).forEach(v => v.group.invoke('remove'));
          Object.values(SEGMENTS).forEach(g => g.group.clearLayers())
          nsegments = 1;
          SEGMENTS = {};
          PROGRESS = {};
          nlines = 1;
          notes_class = "even";
          counter_reset();
      }

      function mean(vals) {
          if(vals.length == 0)
              return undefined;
          let sum = 0;
          for(const v of vals) {
              if(v === undefined)
                  continue
              sum += v;
          }
          sum = sum / vals.length;
          return sum;
      }

      const arrowhead_opts = {
          size: '4px',
          yawn: 60,
          frequency: '66px',
          fill: false,
      }

      function route() {
          let line_color = undefined;
          let last_point = undefined;
          for(const segment of data._route) {
              let level_set = undefined;
              for(const [name, parts] of Object.entries(segment)) {
                  const pts = [];
                  const markers = [];
                  const lines = [];
                  const elevation = [];
                  const away = []
                  let FLY_TO = [];
                  for(const part of parts) {
                      const kind = typeof part;
                      if(kind == "string") {
                          const ret = parse_name(part);
                          elevation.push(... ret.to.map(x => x[1]))
                          pts.push(... ret.to);
                          markers.push(... ret.markers)
                          line_color = (ret.line_color) ? ret.line_color : line_color;
                          level_set = (ret.level) ? ret.level : level_set;
                          FLY_TO.push( ret.to.find(x => x.length) )
                      } else if(kind == "object") {
                          const ret = parse_object(part);
                          elevation.push(... ret.to.map(x => x[1]))
                          if(ret.away.length) {
                              for(const aw of ret.away) {
                                  if(aw.length == 2)
                                      away.push(aw)
                                  else if(aw.length == 1)
                                      away.push([pts.at(-1), aw[0]])
                                  else
                                      console.log("Expected length of 1 or 2 for 'away'")
                              }
                          }
                          pts.push(... ret.to);
                          markers.push(... ret.markers)
                          line_color = (ret.line_color) ? ret.line_color : line_color;
                          level_set = (ret.level) ? ret.level : level_set;
                          if(ret.to.length)
                              FLY_TO.push( ret.to.find(x => x.length ) )
                          else
                              FLY_TO.push( pts.at(-1) )
                      } else {
                          console.log("unexpected kind", kind);
                          FLY_TO.push( [0,0,0])
                      }
                  }
                  // Determine Layer from mean of Elevation (y-coord or pos[1])
                  const mean_ele = mean(elevation);
                  let layer = "Surface";
                  if(mean_ele === undefined) {
                  } else if(mean_ele < 0) {
                      layer = "Depths";
                  } else if(mean_ele > 1000) {
                      layer = "Sky";
                  }
                  if(level_set !== undefined) {
                      layer = level_set;
                  }
                  const seg = route_new_segment(name, layer);

                  for(let i = 0; i < parts.length; i++) {
                      const part = parts[i];
                      const div = route_new_line(part, FLY_TO[i], layer, name);
                      if(div)
                          seg.appendChild(div)
                  }

                  let pl = undefined;
                  if(last_point && last_point.length > 0 && pts.length > 0 && pts[0].length > 0) {
                      let m = [
                          [last_point[2], last_point[0]],
                          [pts[0][2], pts[0][0]]
                      ];
                      pl = L.polyline(m, {color: line_color }).bindTooltip('segment connection', {sticky: true})
                          .arrowheads(arrowhead_opts);
                  }

                  // Get Last actual point
                  let n = pts.length;
                  last_point = pts[n-1];

                  let multi = [];
                  let xll = [];
                  for(const pt of pts) {
                      if(pt.length == 3)
                          xll.push([pt[2], pt[0]])
                      else if(pt.length == 0) {
                          multi.push(xll);
                          xll = [];
                      }
                  }
                  if(xll.length > 0) {
                      multi.push(xll);
                  }
                  multi = multi.filter(m => m.length);
                  if(line_color === undefined) {
                      line_color = '#3388ff';
                  }
                  const tmp = multi.map(m =>
                      L.polyline(m, { color: line_color } ).bindTooltip(name, { sticky: true })
                          .arrowheads(arrowhead_opts)
                  )
                  if(pl)
                      tmp.push(pl);
                  if(away.length) {
                      const away_pl = away
                            .map(pts => pts.map(pt => ll(pt)))
                            .map(pts => L.polyline(pts, { color: 'white' })
                                 .bindTooltip(name, { sticky: true })
                                 .arrowheads(arrowhead_opts)
                                )
                      tmp.push(...away_pl);
                  }
                  SEGMENTS[name] = {
                      layer,
                      group: L.layerGroup(tmp),
                  }
                  markers.forEach(marker => { SEGMENTS[name].group.addLayer(marker); });
                  if(SEGMENTS[name].layer == map_el.level) {
                      SEGMENTS[name].group.invoke('addTo', map_el.map);
                  }
                  //MARKERS.push(...markers);
              }
          }
          {
              const missing = document.getElementById('missing_data');
              missing.innerHTML = "";

              for(const key of Object.keys(_counters).sort()) {
                  const det = document.createElement('details');
                  const sum = document.createElement('summary');
                  const vals = key.split('::');
                  let items = meta;
                  for(const v of vals) {
                      items = items[v];
                  }
                  if(!items)
                      continue
                  const ul = document.createElement('ul');
                  ul.style.marginTop = 0;
                  ul.style.marginBottom = 0;
                  ul.style.fontSize = '0.90em';
                  det.appendChild(ul);
                  for(const item of Object.keys(items).sort()) {
                      if(item in _counters[key])
                          continue
                      const name = document.createElement('li')
                      name.textContent = item;
                      ul.appendChild(name);
                  }
                  const xsum = $div();
                  sum.appendChild(xsum);
                  xsum.classList.add('missing_summary_box');
                  const txt = $div();
                  txt.textContent = key;
                  txt.classList.add('missing_summary');
                  xsum.appendChild(txt);

                  const show = $div();
                  const id = key.replace("::", "_");
                  show.textContent = "Show"
                  show.classList.add('missing_show_hide');
                  show.addEventListener('click', (ev) => {
                      ev.stopPropagation();
                      ev.preventDefault();
                      if(ev.target.textContent == "Show") {
                          show_type(key);
                          ev.target.textContent = "Hide";
                      } else {
                          hide_type(key);
                          ev.target.textContent = "Show";
                      }
                  });
                  xsum.appendChild(show);

                  det.appendChild(sum);
                  missing.appendChild(det);
              }
          }
      }

      function meta_get(key) {
          const vals = key.split("::");
          let items = meta;
          for(const v of vals) {
              items = items[v];
          }
          return items;
      }
      const ALL_MARKERS = {};
      function show_type(key_base) {
          const items = meta_get(key_base);
          if(!items)
              return;
          const group = Object.keys(items).filter(key => {
              return ! counter_has(`${key_base}::${key}`)
          }).map(key => {
              const v = items[key];
              let tooltip = (v.DisplayName != key) ? `${v.DisplayName} ${key}` : key;
              return L.circleMarker(ll(v.pos), { radius: 6, color: '#ff2222'}).bindTooltip(tooltip)
          })
          ALL_MARKERS[key_base] = L.layerGroup(group);
          ALL_MARKERS[key_base].invoke('addTo', map_el.map);
      }
      function hide_type(key) {
          const group = ALL_MARKERS[key];
          if(!group)
              return
          group.invoke('remove')
      }



      async function load_json(filename) {
          const res = await fetch(filename);
          return await res.json();
      }

      let meta = {};
      let icons = {};
      let mappct_data = {} // data from map_pct2.json
      let meta_hash = {}; // hash index into meta data
      let mappct = {}; // key: hash_id; value: map_pct data
      let mappct_flag = {} // key: flag; value: [ map_pct with that flag ]

      function get_hash_ids(obj) {
          if(typeof obj != 'object' || obj === null) {
              return
          }
          if(obj.hash_id) {
              if(obj.hash_id in meta_hash) {
                  console.log("Duplicate hash in meta_hash", obj.hash_id)
              }
              meta_hash[obj.hash_id] = obj
              return
          }
          for(const [key, value] of Object.entries(obj)) {
              get_hash_ids(value)
          }
      }

      const loadIcon = (name, opts) => new Promise( resolve => {
          if(opts.canvas) {
              opts.img = new Image();
              opts.img.src = opts.iconUrl;
              opts.drawIcon = function(canvas, type) {
                  if(type == "icon") {
                      const ctx = canvas.getContext('2d')
                      ctx.drawImage(opts.img, 0, 0, opts.iconSize[0],opts.iconSize[1])
                  }
              }
              opts.img.onload = function() {
                  resolve( L.canvasIcon( opts ))
              }
          } else {
              resolve(L.icon(opts))
          }
      });

      function isObject(x) {
          return(typeof x === 'object' && !Array.isArray(x) && x !== null);
      }

      let NAMES = {};

      async function main() {
          let txt = get_route();
          if(!txt) {
              warn("Populating with basic initial route")
              const res = await fetch('main.celer');
              txt = await res.text();
          }

          meta = await load_json('celer_totk_metadata.json')
          if(meta._icons) {
              for(const [name, opts] of Object.entries(meta._icons)) {
                  if(opts.iconUrl)
                      icons[name] = await loadIcon(name, opts)
                  for(const [name2, opts2] of Object.entries(meta._icons[name])) {
                      if(isObject(opts2) && name2 != "img") {
                          icons[`${name}::${name2}`] = await loadIcon(name2, opts2);
                      }
                  }
              }
          }

          get_hash_ids(meta)

          mappct = {}
          mappct_data = await load_json('map_pct2.json')
          let total = 0;
          for(const [key, values] of Object.entries(mappct_data)) {
              total += values.length;
              let avails = []
              let key0 = ""
              if(key == "towers") {
                  avails = meta.Tower
                  key0 = "Tower"
              }
              for(const value of values) {
                  if(meta_hash[value.hash_id[0]]) {
                      if(value.hash_id[0] in mappct) {
                          console.log("hash already in mappct ", value.hash_id[0], value)
                      }
                      mappct[value.hash_id[0]] = meta_hash[value.hash_id[0]]
                      mappct[value.hash_id[0]].mappct = value
                      if(value.flag == undefined)
                          console.log('flag not defined for', value)
                      if(!(value.flag in mappct_flag))
                          mappct_flag[value.flag] = []
                      mappct_flag[value.flag].push(value)
                      if(key == "towers") {
                          value.flag_alt = value.flag
                              .replace("IsVisitLocation",
                                       "IsOpenCannon")
                      }
                  } else {
                      console.log("cound not find matching location for ",
                                  value, value.hash_id[0])
                  }
              }
          }
          console.log(total, Object.keys(mappct).length)

          for(const word of Object.keys(meta)) {
              if(word == "Enemy") {
                  for(const sub of Object.keys(meta[word])) {
                      completions.push([`_Enemy::${sub}::`, ... Object.keys(meta[word][sub]).sort().map(s => `_Enemy::${sub}::${s}`)]);
                  }
              }
              const dc = (word == "Enemy") ? "::" : "";
              completions.push([`_${word}::`, ... Object.keys(meta[word]).sort().map(s => `_${word}::${s}${dc}`)]);
          }
          NAMES = await load_json("names.json");
          myCodeMirror.setValue(txt);
      }
      main()
      function $div() {
          return document.createElement('div')
      }

      const route_el = document.getElementById('route');
      let nsegments = 1;
      let nlines = 1;
      function route_new_segment(segment_name, layer) {
          const segment = $div();
          segment.classList.add('segment')
          const title = $div();
          title.classList.add('segment_title');
          const data = $div();
          data.classList.add('segment_data');
          const txt = $div();
          txt.textContent = `${nsegments}. ${segment_name}`;
          title.appendChild(txt)
          const box = document.createElement('input')
          box.type = 'checkbox';
          box.checked = true;
          box.addEventListener('change', (ev) => {
              if(ev.target.checked) {
                  SEGMENTS[segment_name].group.invoke('addTo', map);
              } else {
                  SEGMENTS[segment_name].group.invoke('remove');
              }
          })
          const layer_div = $div();
          layer_div.classList.add('segment_title_layer');
          layer_div.textContent = layer;
          title.appendChild(box)
          title.appendChild(layer_div);
          segment.appendChild(title);
          route_el.appendChild(segment);
          segment.appendChild(data);
          nsegments += 1;
          return data;
      }

      function get_meta_item(kind) {
          if(!kind)
              return undefined
          let m = meta;
          for(const v of kind) {
              if(!v.name in m)
                  break
              m = m[v.name]
          }
          return m;
      }

      let notes_class = "even";
      function get_route_icon(kind, warp) {
          if(!kind)
              return undefined;
          if(warp)
              return meta._icons.Warp;
          let icon = meta._icons;
          for(let i = 0; i < kind.length; i++) {
              const v = kind[i];
              if(!(v.name in icon)) {
                  if(i+1 < kind.length && kind[i+1].name in icon)
                      icon = icon[kind[i+1].name]
                  break
              }
              icon = icon[v.name];
          }
          return icon;
      }
      function set_route_icon(ret, div) {
          let kind = get_route_icon(ret.kind, ret.warp);
          if(kind) {
              const img = new Image();
              const size = kind.routeSize;
              img.src = kind.iconUrl;
              div.appendChild(img);
              div.classList.add('segment_line_text_icon');
              if(size) {
                  img.style.width = `${size[0]}px`;
                  img.style.minWidth = `${size[0]}px`;
                  img.style.height = `${size[1]}px`
              }
          }
      }
      const template = function(templateString, templateVars){
          var func = new Function(...Object.keys(templateVars),  "return `"+templateString +"`;")
          return func(...Object.values(templateVars));
      }

      function displayString(ret) {
          const icon = get_route_icon(ret.kind, ret.warp);
          if(!icon || !icon.displayString)
              return ret.txt
          return template(icon.displayString, {
              txt: ret.txt, key: ret.key, meta: get_meta_item(ret.kind)
          })
      }

      function removeElementsByClass(className){
          const elements = document.getElementsByClassName(className);
          while(elements.length > 0){
              elements[0].classList.remove(className);
          }
      }

      function hide_all_segments() {
          for(const [key, segment] of Object.entries(SEGMENTS)) {
              segment.group.invoke('remove')
          }
      }

      let PROGRESS = {};
      let CURRENT_LINE = undefined;
      function set_current_line(id) {
          if(id == undefined) {
              CURRENT_LINE = undefined;
              removeElementsByClass('line_active')
              return;
          }
          removeElementsByClass('line_active')
          const el = document.getElementById(id);
          el.classList.add('line_active');
          CURRENT_LINE = id;
          switch_layer(el.dataset.layer);
          if(el.dataset.xyz) {
              const xyz = el.dataset.xyz.split(",").map(x => parseFloat(x));
              map_el.map.panTo(ll(xyz), { animate: true } );
          }
          // This hides all segments except for the current segment
          if(ONLY_SEGMENT) {
              hide_all_segments()
              SEGMENTS[el.dataset.segment].group.invoke('addTo', map_el.map);
          }
          if(SHOW_PROGRESS) {
              let n = parseInt(id.replace("line_",""))
              while(n >= 0) {
                  if(PROGRESS[n]) {
                      update_progress( PROGRESS[n]);
                      break;
                  }
                  n -= 1;
              }
          }
      }

      function update_progress(progress) {
          for(const key of Object.keys(progress)) {
              let el = document.getElementById(`progress_${key}`);
              if(el) {
                  if(key == 'mappct') {
                      const pct = (100 * progress[key] / 2492);
                      el.innerText = pct.toFixed(2);
                      const title = `map% ${progress[key]} / 2492 = ${pct.toFixed(5)}%`
                      el.title = title
                      document.getElementById(`progress_icon_${key}`).title = title;
                  }
                  else {
                      el.innerText = progress[key];
                  }
              }
          }
      }

      function route_new_line(part, xyz, line_layer, segment_name) {
          if(part == undefined || part == null)
              return undefined;
          const line = $div();
          line.classList.add('segment_line')
          line.id = `line_${nlines}`;
          if(xyz !== undefined)
              line.dataset.xyz = xyz;
          line.dataset.layer = line_layer;
          line.dataset.segment = segment_name;
          line.addEventListener('click', (ev) => {
              set_current_line(ev.currentTarget.id);
          });
          const num = $div();
          num.classList.add('segment_line_number');
          num.textContent = `${nlines}`;
          line.appendChild(num);
          const current_line = nlines;
          nlines += 1

          const counter = $div();
          counter.classList.add('segment_line_counter');
          line.appendChild(counter);

          const text_cell = $div();
          text_cell.classList.add('segment_line_text');
          line.appendChild(text_cell);

          const text_cell_wrap = $div()
          text_cell_wrap.classList.add('segment_line_text_row')
          text_cell.appendChild(text_cell_wrap);
          const icon = $div();
          text_cell_wrap.appendChild(icon);
          const text_cell_wrap_col = $div();
          text_cell_wrap_col.classList.add('segment_line_text_column')
          text_cell_wrap.appendChild(text_cell_wrap_col);
          const text = $div();
          text.classList.add('segment_line_text_text');
          text_cell_wrap_col.appendChild(text);
          const comment = $div();
          comment.classList.add('segment_line_text_comment');
          text_cell_wrap_col.appendChild(comment);

          const notes = $div();
          notes.classList.add('segment_line_notes');
          line.appendChild(notes);
          if(typeof part == "string") {
              const ret = parse_name_to_line(part);
              const count = counter_inc(ret.kind, ret.key, ret.warp);
              if(count != undefined) {
                  counter.textContent = `${count}`;
                  counter.title = ret.kind.map(v=>v.name).join('::');
                  PROGRESS[current_line] = counter_total();
              }
              set_route_icon(ret, icon)
              text.textContent = displayString(ret)

              if(ret.comment)
                  comment.textContent = ret.comment;
              return line;
          }
          const name = Object.keys(part)[0]
          const vals = part[name];
          if(!vals)
              return undefined;
          const ret = parse_name_to_line(name);
          const count = counter_inc(ret.kind, ret.key, ret.warp);
          if(count != undefined) {
              counter.textContent = `${count}`;
              counter.title = ret.kind.map(v=>v.name).join('::');
              PROGRESS[current_line] = counter_total();
          }
          set_route_icon(ret, icon)
          text.textContent = displayString(ret);
          if(vals.notes) {
              notes.textContent = vals.notes;
              notes.classList.add(notes_class);
              notes_class = (notes_class == "even") ? "odd" : "even";
          }
          if(ret.comment)
              comment.textContent = ret.comment;
          else if(vals.comment)
              comment.textContent = vals.comment;

          return line;
      }

      function switch_layer(level) {
          if(level == map_el.level)
              return;
          map_el.map.removeLayer(baseMapLayers[map_el.level])
          baseMapLayers[level].addTo(map_el.map);
          map_el.level = level;
      }

      map_el.map.on('baselayerchange', (ev) => {
          switch_segments(ev.name);
          map_el.level = ev.name;
      });

      function get_next_line(dir) {
          if(CURRENT_LINE === undefined)
              return undefined;
          //console.log('CURRENT LINE', CURRENT_LINE);
          let n = parseInt(CURRENT_LINE.split("_")[1]);
          if(n === undefined) {
              console.log("could not get line number", CURRENT_LINE);
              return undefined;
          }
          n += dir;
          let next_id = `line_${n}`;
          let next = document.getElementById(next_id);
          if(!next) {
              //console.log("could not find next line", next_id);
              return undefined;
          }
          return next;
      }

      let SHOW_PROGRESS = false; // Ctrl-P
      let ONLY_SEGMENT = false;  // Ctrl-O

      function key_commands(ev) {
          if(ev.ctrlKey && ev.key == "p") {
              SHOW_PROGRESS = ! SHOW_PROGRESS;
              const el = document.getElementById("progress0");
              el.style.display = (SHOW_PROGRESS) ? 'block' : 'none';
              set_current_line(CURRENT_LINE);
              return;
          }
          if(ev.ctrlKey && ev.key == "o") {
              ONLY_SEGMENT = ! ONLY_SEGMENT;
              if(!ONLY_SEGMENT) {
                  switch_segments(map_el.level);
              }
              set_current_line(CURRENT_LINE);
              return;
          }

          if(CURRENT_LINE === undefined)
              return
          if(ev.key == "ArrowDown" || ev.key == "ArrowUp") {
              let next;
              if(ev.key == "ArrowDown")
                  next = get_next_line(1);
              else if(ev.key == "ArrowUp")
                  next = get_next_line(-1);
              if(next === undefined)
                  return;
              const xoffset = 0;
              const route = document.getElementById('route')
              const yoffset = next.offsetTop - route.offsetTop - 40;
              //console.log(ev.key, next.id, yoffset, route.scrollTop, yoffset - route.scrollTop, route.offsetTop);
              route.scrollTo(xoffset, yoffset)
              //console.log(ev.key, next.id, route.scrollTop);
              set_current_line(next.id);
              ev.stopPropagation()
              ev.preventDefault()
              return false;
          }
      }
      window.addEventListener('keydown', key_commands);
      </script>
  </body>
</html>
